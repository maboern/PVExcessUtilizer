/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
class HeatPumpRoomThermostat {
    constructor(root_obj, heatpump, pv_forecast) {
        this.root_obj = root_obj + ".thermostat";
        this.heatpump = heatpump;
        this.stats = this.heatpump.getStats();
        this.pv_forecast = pv_forecast;
        this.DEBUG = false;

        this.hk2_room_temp_target_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 2.val10980';     
        this.hk3_room_temp_target_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 3.val10986';
        this.hk2_heating_curve_gradient_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 2.val26'; /*Steigung heizkurve*/
        this.hk3_heating_curve_gradient_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 3.val10991'; /*Steigung heizkurve*/

        this.hk2_room_temp_comfort = 21;
        this.hk2_room_temp_high = 21.6;
        this.hk2_room_temp_eco = 20.6;
        this.hk3_room_temp_comfort = 21.8;
        this.hk3_room_temp_high = 22.8;
        this.hk3_room_temp_eco = 21.4;
        
        this.min_room_overheating_threshold = 0.2;

        this.hk2_room_temp_before_deactivation = undefined;
        this.hk3_room_temp_before_deactivation = undefined;
    }

    estimateHeatingCircuitTemp(room_temp, ambient_temp, gradient) {
        return room_temp + (room_temp - ambient_temp)*gradient;
    }
    estimateTargetHeatingCircuitTempHk2() {
        let gradient = getStateIfExisting(this.hk2_heating_curve_gradient_obj, 0.5);
        return this.estimateHeatingCircuitTemp(this.hk2_room_temp_comfort, this.stats.getAmbientTemp(), gradient);
    }
    estimateTargetHeatingCircuitTempHk3() {
        let gradient = getStateIfExisting(this.hk3_heating_curve_gradient_obj, 0.5);
        return this.estimateHeatingCircuitTemp(this.hk3_room_temp_comfort, this.stats.getAmbientTemp(), gradient);
    }
    getEfficientTargetHeatingBufferTemp() {
        return Math.max(this.estimateTargetHeatingCircuitTempHk2(), this.estimateTargetHeatingCircuitTempHk3());
    }
    getEfficientMaxHeatingBufferTemp() {
        let target_temp = this.getEfficientTargetHeatingBufferTemp();
        return this.heatpump.calculateHeatingBufferMaxFromTarget(target_temp);
    }
    estimateHourlyTemperatureLoss() {
        const NORM_TEMP_LOSS_PER_HOUR = 0.125; // 째C lost per hour at 0째C
        let ambient_temp = this.stats.getAmbientTemp();
        return Math.max((20 - ambient_temp)/20 * NORM_TEMP_LOSS_PER_HOUR, 0.001);
    }
    estimateHoursUntilUndercooled() {
        let temp_reserve_hk2 = this.stats.getRoomTempHk2() - this.hk2_room_temp_eco;
        let temp_reserve_hk3 = this.stats.getRoomTempHk3() - this.hk3_room_temp_eco;
        let min_temp_reserve = Math.min(temp_reserve_hk2, temp_reserve_hk3);
        return min_temp_reserve / this.estimateHourlyTemperatureLoss();
    }
          
    setRoomTargetTempHigh(reason) {
        if(!this.isRoomTargetTempHigh()) {
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_high, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_high, false);
            console.log("Set Room thermostat to HIGH: " + reason);
            return true;
        }
        return false;
    }
    isRoomTargetTempHigh() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort);
        return hk3_room_temp_target >= this.hk3_room_temp_high;
    }

    setRoomTargetTempComfort(reason) {
        if(!this.isRoomTargetTempComfort()) { 
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_comfort, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort, false);
            console.log("Set Room thermostat to COMFORT: " + reason);
            return true;
        }
        return false;
    }
    isRoomTargetTempComfort() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort);
        return hk3_room_temp_target < this.hk3_room_temp_high && hk3_room_temp_target > this.hk3_room_temp_eco;
    }

    setRoomTargetTempEco(reason) {
        if(!this.isRoomTargetTempEco()) {
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_eco, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_eco, false);
            console.log("Set Room thermostat to ECO: " + reason);
            return true;
        }
        return false;
    }
    isRoomTargetTempEco() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_eco);
        return hk3_room_temp_target < this.hk3_room_temp_comfort;
    }

    checkRoomTargetTempMatches(obj, match) { return getStateIfExisting(obj, match) == match;}

    isHk2RoomOverheated() {
        let hk2_room_temp = this.stats.getRoomTempHk2();
        return hk2_room_temp > this.hk2_room_temp_comfort + this.min_room_overheating_threshold;
    }
    isHk3RoomOverheated() {
        let hk3_room_temp = this.stats.getRoomTempHk3();
        return hk3_room_temp > this.hk3_room_temp_comfort + this.min_room_overheating_threshold;
    }
    areAllRoomsOverheated() { return this.isHk2RoomOverheated() && this.isHk3RoomOverheated();}

    isHk2RoomAtComfortTemp() { return this.stats.getRoomTempHk2() >= this.hk2_room_temp_comfort; }
    isHk3RoomAtComfortTemp() { return this.stats.getRoomTempHk3() >= this.hk3_room_temp_comfort; }
    isAnyRoomAtComfortTemp() { return this.isHk2RoomAtComfortTemp() || this.isHk3RoomAtComfortTemp(); }

    isHk2RoomUndercooled() { return this.stats.getRoomTempHk2() < this.hk2_room_temp_eco; }
    isHk3RoomUndercooled() { return this.stats.getRoomTempHk3() < this.hk3_room_temp_eco; }
    areAllRoomsUndercooled() { return this.isHk2RoomUndercooled() && this.isHk3RoomUndercooled(); }
    isAnyRoomUndercooled() { return this.isHk2RoomUndercooled() || this.isHk3RoomUndercooled();}
    deactivateHeating() {
        this.hk2_room_temp_before_deactivation = this.stats.getRoomTempHk2();
        this.hk3_room_temp_before_deactivation = this.stats.getRoomTempHk3();
        this.heatpump.setOperatingModeWarmWaterOnly();
    }
    reactivateHeating() {
        let temp_loss_hk2 = this.stats.getRoomTempHk2() - this.hk2_room_temp_before_deactivation;
        let temp_loss_hk3 = this.stats.getRoomTempHk3() - this.hk3_room_temp_before_deactivation;
        let secs_in_prev = this.heatpump.resetOperatingMode();
        if(secs_in_prev > 0) {
            let hourly_temp_loss_hk2 = Math.round(temp_loss_hk2 * 100 / (secs_in_prev/3600))/100;
            let hourly_temp_loss_hk3 = Math.round(temp_loss_hk3 * 100 / (secs_in_prev/3600))/100;
            console.log("Reactivated heating. Temperature loss: HK2 = " + temp_loss_hk2 + "K (" + hourly_temp_loss_hk2 + "K/h), HK3 = " + temp_loss_hk3 + "K (" + hourly_temp_loss_hk3 + "K/h)");
        }
    }

    controlDay(overpowered, heating_mode, min_power, max_power) {
        this.reactivateHeating();

        let buffering = heating_mode == HEATPUMP_MODE.BUFFERING;
        let after_buffering = this.stats.getHeatingBufferTemp() >= this.getEfficientMaxHeatingBufferTemp();

        let min_required_heating_power = this.heatpump.getExpectedHeatingPower();
        let surplus_forecasted_now = this.pv_forecast.upcomingSurplusForecasted(0, min_required_heating_power, 1.2);
        let surplus_forecasted_soon = this.pv_forecast.upcomingSurplusForecasted(60, min_required_heating_power, 1.2);
        let surplus_now = min_power > min_required_heating_power;
        let surplus_start = surplus_forecasted_soon && surplus_forecasted_now && surplus_now; 

        let expected_heating_power = this.heatpump.estimateExpectedHeatingPower(this.getEfficientTargetHeatingBufferTemp());
        let remaining_heating_surplus_time = this.pv_forecast.estimateRemainingSurplusToday(expected_heating_power);
        let low_remaining_surplus_forecasted = remaining_heating_surplus_time <= 0;
        let low_surplus_now = max_power < this.heatpump.getExpectedHeatingPower();
        let is_after_forecasted_peak = (this.pv_forecast.getSecondsAfterPeakTime() > 0);
        let surplus_stop = is_after_forecasted_peak && low_remaining_surplus_forecasted && low_surplus_now;
    

        if(buffering) {
            return this.setRoomTargetTempEco("Buffering");
        } else if(after_buffering) {
            return overpowered ? this.setRoomTargetTempEco("After Buffering") : this.setRoomTargetTempComfort("After Buffering");
        } else if(surplus_start || (this.isRoomTargetTempHigh() && !surplus_stop)) {
            return this.setRoomTargetTempHigh("Surplus");
        } else {
            return this.setRoomTargetTempComfort("Default");
        }
    }

    controlNight(overpowered) {
        let hours_until_undercooled = this.estimateHoursUntilUndercooled();
        if(overpowered && hours_until_undercooled > 4) {
            this.deactivateHeating();
            return;
        } else if(this.heatpump.isOperatingModeWarmWaterOnly() && hours_until_undercooled < 0.75) {
            this.reactivateHeating();
        }

        let heating_on = this.heatpump.isHeatingOn() || this.heatpump.isHeatingStartingUp();
        let at_efficient_max = this.stats.getHeatingBufferTemp() >= this.getEfficientMaxHeatingBufferTemp();

        let max_overheat = Math.max(this.getEfficientMaxHeatingBufferTemp() - this.getEfficientTargetHeatingBufferTemp(), 1);
        let overheat = Math.min(Math.max(this.stats.getHeatingBufferTemp() - this.getEfficientTargetHeatingBufferTemp(), 1), max_overheat);
        let max_overheat_time = 8*60*60*1000 / overheat; 
        if(this.DEBUG) { console.log("Efficient Target: " + this.getEfficientTargetHeatingBufferTemp() + "째C, Overheat: " + overheat + "K/" + max_overheat + "K => Max Overheat Time: " + max_overheat_time/(60*1000) + "min"); }
       /* let within_allowed_overheat_time = isNowInTimePeriod(this.heatpump.getHeatingStartTimeStamp(), max_overheat_time);
        let above_heating_target = this.stats.getHeatingBufferTemp() > this.heatpump.getTargetHeatingBufferTemp();
        let above_high_heating_target = this.isRoomTargetTempHigh() && above_heating_target;
        let within_efficient_heating_limits = true;//within_allowed_overheat_time;// && !above_high_heating_target;*/

        if(overpowered) {
            if(at_efficient_max) {
                return this.setRoomTargetTempEco("Night Overpowered - Buffer high"); // Restrict energy outflow to slow down buffer outflow
            } 
            if(this.isAnyRoomAtComfortTemp() && !this.isAnyRoomUndercooled()) {
                return this.setRoomTargetTempEco("Night Overpowered - Rooms warm");
            } else {
                if(heating_on) {
                    return this.setRoomTargetTempHigh("Night Overpowered - Heating On"); // Increase energy outflow while heating with a low buffer.
                } else {
                    return this.setRoomTargetTempEco("Night Overpowered - Stretch heating pause");
                }
            }
        } else {
            return this.setRoomTargetTempComfort("Night Default");
        }
    }

    control(heating_mode, min_power, max_power)  {
        if(this.stats.isInSummerMode()) { return this.setRoomTargetTempComfort(); }
        let overpowered = this.heatpump.isInOverpoweredRegime(this.getEfficientTargetHeatingBufferTemp());
        if(this.DEBUG) { console.log("Target Heating Buffer Temp: " + this.getEfficientTargetHeatingBufferTemp() + "째C.")}
        if(this.pv_forecast.isNight()) {
            return this.controlNight(overpowered);
        } else {
            return this.controlDay(overpowered, heating_mode, min_power, max_power);
        }
    }
}
