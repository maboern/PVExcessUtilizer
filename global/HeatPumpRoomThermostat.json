/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
const ROOM_THERMOSTAT_SETTING = Object.freeze({
    OFF : 0, 
    ECO : 1,  
    COMFORT : 2, 
    HIGH: 3,  
    STANDBY : 4
});

class HeatPumpRoomThermostat {
    constructor(root_obj, heatpump, pv_forecast) {
        this.root_obj = root_obj + ".thermostat";
        this.heatpump = heatpump;
        this.stats = this.heatpump.getStats();
        this.pv_forecast = pv_forecast;
        this.DEBUG = false;

        this.hk2_room_temp_target_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 2.val10980';     
        this.hk3_room_temp_target_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 3.val10986';
        this.hk2_heating_curve_gradient_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 2.val26'; /*Steigung heizkurve*/
        this.hk3_heating_curve_gradient_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 3.val10991'; /*Steigung heizkurve*/

        this.setting = undefined;
        this.overpowered = undefined;
        this.is_dark = undefined;
        
        this.hk2_room_temp_comfort = 21;
        this.hk2_room_temp_high = 21.6;
        this.hk2_room_temp_eco = 20.6;
        this.hk3_room_temp_comfort = 22.0;
        this.hk3_room_temp_high = 23.0;
        this.hk3_room_temp_eco = 21.6;
        this.room_temp_off = 15;
        
        this.min_room_overheating_threshold = 0.2;
        this.standby_min_hours = 5;
        this.standby_reactivation_hours = 3;

        this.hk2_room_temp_before_deactivation = undefined;
        this.hk3_room_temp_before_deactivation = undefined;

        this.SETTING_OBJ = this.root_obj + ".setting";
        createState(this.SETTING_OBJ, 0, {read: true, write: false, name: "Thermostat Setting", type: "number", min: 0, max: 4, def: 0, states: {0:'OFF', 1:'ECO', 2:'COMFORT', 3:'HIGH', 4:'STANDBY'}});
        
    }

    estimateHeatingCircuitTemp(room_temp, ambient_temp, gradient) {
        return room_temp + (room_temp - ambient_temp)*gradient;
    }
    estimateTargetHeatingCircuitTempHk2() {
        let gradient = getStateIfExisting(this.hk2_heating_curve_gradient_obj, 0.5);
        return this.estimateHeatingCircuitTemp(this.hk2_room_temp_comfort, this.stats.getAmbientTemp(), gradient);
    }
    estimateTargetHeatingCircuitTempHk3() {
        let gradient = getStateIfExisting(this.hk3_heating_curve_gradient_obj, 0.5);
        return this.estimateHeatingCircuitTemp(this.hk3_room_temp_comfort, this.stats.getAmbientTemp(), gradient);
    }
    getEfficientTargetHeatingBufferTemp() {
        return Math.max(this.estimateTargetHeatingCircuitTempHk2(), this.estimateTargetHeatingCircuitTempHk3());
    }
    getEfficientMaxHeatingBufferTemp() {
        let target_temp = this.getEfficientTargetHeatingBufferTemp();
        return this.heatpump.calculateHeatingBufferMaxFromTarget(target_temp);
    }
    estimateHourlyTemperatureLoss() {
        // Measured: HK2 -0.05K/h @ ~8°C
        const NORM_TEMP_LOSS_PER_HOUR = 0.11; // °C lost per hour at 0°C
        let ambient_temp = this.stats.getAmbientTemp();
        return Math.max((20 - ambient_temp)/20 * NORM_TEMP_LOSS_PER_HOUR, 0.001);
    }
    estimateHoursUntilAtMinTemp(hk2_min_temp, hk3_min_temp) {
        let temp_reserve_hk2 = this.stats.getRoomTempHk2() - hk2_min_temp;
        let temp_reserve_hk3 = this.stats.getRoomTempHk3() - hk3_min_temp;
        let min_temp_reserve = Math.min(temp_reserve_hk2, temp_reserve_hk3);
        return min_temp_reserve / this.estimateHourlyTemperatureLoss();
    }
    estimateHoursUntilUndercooled() { return this.estimateHoursUntilAtMinTemp(this.hk2_room_temp_eco, this.hk3_room_temp_eco); }
    estimateHoursUntilAtComfort() { return this.estimateHoursUntilAtMinTemp(this.hk2_room_temp_comfort, this.hk3_room_temp_comfort); }

    estimateHourlyWarmupTemperatureGain() {
        let equilibrium_power = this.heatpump.estimateEquilibriumHeatingOutputPower();
        let heating_power = this.heatpump.estimateEfficientWarmupOutputPower(this.getEfficientTargetHeatingBufferTemp());
        let net_power = Math.max(heating_power - equilibrium_power, 0.01);
        
        // Auslegung Heizug: 7.8kW @ -10°C - linear interpolation to 0kW @ +20°C 
        // => ~3kW @ 8°C ~= -0.05K/h measured temp loss w/o heating @ 8°C
        return (net_power / 3000) * 0.05;
    }
    estimateWarmupHoursUntilOverheated() {
        let temp_gap_hk2 = this.hk2_room_temp_high - this.stats.getRoomTempHk2();
        let temp_gap_hk3 = this.hk3_room_temp_high - this.stats.getRoomTempHk3();
        let min_temp_gap = (temp_gap_hk2 + temp_gap_hk3) / 2;
        return min_temp_gap / this.estimateHourlyWarmupTemperatureGain();
    }
          
    setRoomTargetTempHigh(reason) {
        if(!this.isRoomTargetTempHigh()) {
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_high, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_high, false);
            console.log("Set Room thermostat to HIGH: " + reason);
            return true;
        }
        setState(this.SETTING_OBJ, ROOM_THERMOSTAT_SETTING.HIGH, true);
        return false;
    }
    isRoomTargetTempHigh() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort);
        return hk3_room_temp_target >= this.hk3_room_temp_high;
    }

    setRoomTargetTempComfort(reason) {
        if(!this.isRoomTargetTempComfort()) { 
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_comfort, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort, false);
            console.log("Set Room thermostat to COMFORT: " + reason);
            return true;
        }
        setState(this.SETTING_OBJ, ROOM_THERMOSTAT_SETTING.COMFORT, true);
        return false;
    }
    isRoomTargetTempComfort() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort);
        return hk3_room_temp_target < this.hk3_room_temp_high && hk3_room_temp_target > this.hk3_room_temp_eco;
    }

    setRoomTargetTempEco(reason) {
        if(!this.isRoomTargetTempEco()) {
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_eco, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_eco, false);
            console.log("Set Room thermostat to ECO: " + reason);
            return true;
        }
        setState(this.SETTING_OBJ, ROOM_THERMOSTAT_SETTING.ECO, true);
        return false;
    }
    isRoomTargetTempEco() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_eco);
        return hk3_room_temp_target < this.hk3_room_temp_comfort;
    }

    setRoomTargetTempOff(reason) {
        if(!this.isRoomTargetTempOff()) {
            setState(this.hk2_room_temp_target_obj, this.room_temp_off, false);
            setState(this.hk3_room_temp_target_obj, this.room_temp_off, false);
            console.log("Set Room thermostat to OFF: " + reason);
            return true;
        }
        setState(this.SETTING_OBJ, ROOM_THERMOSTAT_SETTING.OFF, true);
        return false;
    }
    isRoomTargetTempOff() {
        return this.checkRoomTargetTempMatches(this.hk3_room_temp_target_obj, this.room_temp_off);
    }

    checkRoomTargetTempMatches(obj, match) { return getStateIfExisting(obj, match) == match;}

    isHk2RoomOverheated() {
        return this.stats.getRoomTempHk2() > this.hk2_room_temp_comfort + this.min_room_overheating_threshold;
    }
    isHk3RoomOverheated() {
        return this.stats.getRoomTempHk3() > this.hk3_room_temp_comfort + this.min_room_overheating_threshold;
    }
    areAllRoomsOverheated() { return this.isHk2RoomOverheated() && this.isHk3RoomOverheated();}
    isAnyRoomOverheated() { return this.isHk2RoomOverheated() || this.isHk3RoomOverheated(); }

    isHk2RoomAtMaxOverheatedTemp() { return this.stats.getRoomTempHk2() >= this.hk2_room_temp_high; }
    isHk3RoomAtMaxOverheatedTemp() { return this.stats.getRoomTempHk3() >= this.hk3_room_temp_high; }
    isAnyRoomAtMaxOverheatedTemp() { return this.isHk2RoomAtMaxOverheatedTemp() || this.isHk3RoomAtMaxOverheatedTemp(); }
    areAllRoomsAtMaxOverheatedTemp() { return this.isHk2RoomAtMaxOverheatedTemp() && this.isHk3RoomAtMaxOverheatedTemp(); }

    isHk2RoomAtComfortTemp() { return this.stats.getRoomTempHk2() >= this.hk2_room_temp_comfort; }
    isHk3RoomAtComfortTemp() { return this.stats.getRoomTempHk3() >= this.hk3_room_temp_comfort; }
    isAnyRoomAtComfortTemp() { return this.isHk2RoomAtComfortTemp() || this.isHk3RoomAtComfortTemp(); }
    areAllRoomsAtComfortTemp() { return this.isHk2RoomAtComfortTemp() && this.isHk3RoomAtComfortTemp(); }

    isHk2RoomUndercooled() { return this.stats.getRoomTempHk2() < this.hk2_room_temp_eco; }
    isHk3RoomUndercooled() { return this.stats.getRoomTempHk3() < this.hk3_room_temp_eco; }
    areAllRoomsUndercooled() { return this.isHk2RoomUndercooled() && this.isHk3RoomUndercooled(); }
    isAnyRoomUndercooled() { return this.isHk2RoomUndercooled() || this.isHk3RoomUndercooled();}

    deactivateHeating() {
        this.hk2_room_temp_before_deactivation = this.stats.getRawRoomTempHk2();
        this.hk3_room_temp_before_deactivation = this.stats.getRawRoomTempHk3();
        if(this.heatpump.setOperatingModeWarmWaterOnly()) {
            this.reportStatus();
        }
        setState(this.SETTING_OBJ, ROOM_THERMOSTAT_SETTING.STANDBY, true);
    }
    reactivateHeating() {
        let temp_loss_hk2 = this.stats.getRawRoomTempHk2() - this.hk2_room_temp_before_deactivation;
        let temp_loss_hk3 = this.stats.getRawRoomTempHk3() - this.hk3_room_temp_before_deactivation;
        let secs_in_prev = this.heatpump.resetOperatingMode();
        if(secs_in_prev > 0) {
            let hourly_temp_loss_hk2 = Math.round(temp_loss_hk2 * 1000 / (secs_in_prev/3600))/1000;
            let hourly_temp_loss_hk3 = Math.round(temp_loss_hk3 * 1000 / (secs_in_prev/3600))/1000;
            console.log("Reactivated heating. Temperature loss: HK2 = " + Math.round(temp_loss_hk2*100)/100 + "K (" + hourly_temp_loss_hk2 + "K/h), HK3 = " + Math.round(temp_loss_hk3*100)/100 + "K (" + hourly_temp_loss_hk3 + "K/h)");
        }
    }

    controlLight(overpowered, min_power, max_power) {
        let full_buffer = this.stats.getHeatingBufferTemp() >= this.getEfficientMaxHeatingBufferTemp();
        let high_buffer = this.stats.getHeatingBufferTemp() > this.getEfficientTargetHeatingBufferTemp();
        let low_buffer = this.stats.getHeatingBufferTemp() < Math.min(this.stats.getTargetTempHk2(), this.stats.getTargetTempHk3());
        let high_buffer_start = high_buffer && this.isAnyRoomOverheated() && !this.areAllRoomsAtMaxOverheatedTemp();
        let high_buffer_stop = low_buffer || full_buffer || this.areAllRoomsAtMaxOverheatedTemp();
        
        let min_required_heating_power = this.heatpump.getExpectedHeatingPower();
        let surplus_forecasted_now = this.pv_forecast.upcomingSurplusForecasted(0, min_required_heating_power, 1.0);
        let surplus_forecasted_soon = this.pv_forecast.upcomingSurplusForecasted(60, min_required_heating_power, 1.0);
        let surplus_now = min_power > min_required_heating_power;
        let surplus_start = surplus_forecasted_soon && surplus_forecasted_now && surplus_now; 

        let expected_heating_power = this.heatpump.estimateExpectedHeatingPower(this.getEfficientTargetHeatingBufferTemp());
        let remaining_heating_surplus_time = this.pv_forecast.estimateRemainingSurplusToday(expected_heating_power);
        let no_remaining_surplus_forecasted = remaining_heating_surplus_time <= 0;
        let low_surplus_now = max_power < this.heatpump.getExpectedHeatingPower();
        let surplus_stop = no_remaining_surplus_forecasted && low_surplus_now;

        let standby = this.controlHeatingStandbyLight(overpowered, surplus_stop);
        if(standby) { return; }
        if(high_buffer_start || (this.isRoomTargetTempHigh() && !high_buffer_stop)) {
            return this.setRoomTargetTempHigh("High Buffer");
        } if(surplus_start || (this.isRoomTargetTempHigh() && !surplus_stop)) {
            return this.setRoomTargetTempHigh("Surplus");
        } else {
            return this.setRoomTargetTempComfort("Default");
        }
    }

    controlHeatingStandbyLight(overpowered, surplus_stop) {
        let goto_standby_allowed = this.areAllRoomsOverheated() && surplus_stop;
        let temp_reserve_hours = overpowered ? this.estimateHoursUntilUndercooled() : this.estimateHoursUntilAtComfort();
        if(this.controlHeatingStandby(goto_standby_allowed, temp_reserve_hours)) {
            return true;
        } else { // Default state for day
            this.reactivateHeating();
            return false;
        }
    }

    controlHeatingStandbyDarkness(overpowered) {
        let now = new Date();
        let allow_undercooling = overpowered || (now.getHours() > 12 && now.getHours() < 18);
        let temp_reserve_hours = allow_undercooling ? this.estimateHoursUntilUndercooled() : this.estimateHoursUntilAtComfort();
        let estimated_end_time = addMinutes(now, (temp_reserve_hours - this.standby_reactivation_hours)*60);
        let end_time_after_evening_break = estimated_end_time.getHours() >= 20;
        let end_time_at_night = estimated_end_time.getHours() < 12;
        let goto_standby_allowed = (end_time_after_evening_break || end_time_at_night); 
        return this.controlHeatingStandby(goto_standby_allowed, temp_reserve_hours);
    }
    
    controlHeatingStandby(goto_standby_allowed, temp_reserve_hours) {
        if(goto_standby_allowed && temp_reserve_hours > this.standby_min_hours) {
            this.deactivateHeating();
            return true;
        } else if(this.heatpump.isOperatingModeWarmWaterOnly()) {
            if(temp_reserve_hours < this.standby_reactivation_hours) {
                this.reactivateHeating();
            }
            return true;
        }
        return false;
    }

    controlDarkness(overpowered) {
        let standby = this.controlHeatingStandbyDarkness(overpowered);
        if(standby) { return; }

        let heating_on = this.heatpump.isHeatingOn() || this.heatpump.isHeatingStartingUp();
        let at_efficient_max = this.stats.getHeatingBufferTemp() >= this.getEfficientMaxHeatingBufferTemp();
        let within_overheat_burst_time = isNowInTimePeriod(this.heatpump.getHeatingStartTimeStamp(), 2*60*60*1000);
        let burst_overheating = within_overheat_burst_time && !this.isAnyRoomOverheated();
        let allowed_to_overheat = this.isAnyRoomUndercooled() || burst_overheating;

        if(overpowered) {
            if(at_efficient_max) {
                return this.setRoomTargetTempEco("Darkness Overpowered - Buffer high"); // Restrict energy outflow to slow down buffer outflow
            } else if(heating_on) {
                if(allowed_to_overheat) {
                    return this.setRoomTargetTempHigh("Darkness Overpowered - Stretch heating burst"); // Increase energy outflow while heating with a low buffer.
                } else {
                    return this.setRoomTargetTempComfort("Darkness Overpowered - Heating On");
                }
            } else {
                return this.setRoomTargetTempEco("Darkness Overpowered - Stretch heating pause");
            }
        } else {
            return this.setRoomTargetTempComfort("Darkness Default");
        }
    }

    control(min_power, max_power)  {
        if(this.overpowered == undefined) { this.updateOverpowered(); }
        if(this.stats.isInSummerMode()) { return this.setRoomTargetTempComfort(); }
        this.processDarkLightSwitch();
        if(this.is_dark) {
            return this.controlDarkness(this.overpowered);
        } else {
            return this.controlLight(this.overpowered, min_power, max_power);
        }
    }

    processDarkLightSwitch() {
        let base_power = this.pv_forecast.getBasePowerReserve();
        let is_dark = this.pv_forecast.isNight() || this.pv_forecast.isDawn(base_power) || this.pv_forecast.isDusk(base_power);
        if(is_dark != this.is_dark) {
            let mode = is_dark ? "DARKNESS" : "LIGHT";
            console.log("Thermostat mode changed to " + mode + ".");
            this.is_dark = is_dark;
        }
    }

    updateOverpowered() { this.overpowered = this.heatpump.isInOverpoweredRegime();}
    updateHourly() {
        this.updateOverpowered();
        this.reportStatus();
    }

    reportStatus() {
        if(!this.stats.isInSummerMode() && this.heatpump.isOperatingModeWarmWaterOnly()) {
            let hours_until_undercooled = Math.round(10*this.estimateHoursUntilUndercooled())/10;
            let hk2_temp = Math.round(10*this.stats.getRawRoomTempHk2())/10;
            let hk3_temp = Math.round(10*this.stats.getRawRoomTempHk3())/10;
            let is_dark = this.is_dark ? "DARKNESS" : "LIGHT";
            let is_overpowered = this.overpowered ? "OVERPOWERED" : "CONTINUOUS";
            console.log("Thermostat (" + is_dark + ", " + is_overpowered + ") STANDBY: " + hours_until_undercooled + "h temperature reserve (HK2=" + hk2_temp + "°C, HK3=" + hk3_temp + "°C)");
        }
    }
}
