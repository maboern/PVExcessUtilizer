/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
const PV_POWER_ESTIMATION_MODE = Object.freeze({
    MPPT : "MPPT",
    MAX : "MAX"
});

class PVSystem {
    constructor(name) {
        this.name = name;
        this.SCRIPT_ID = 'javascript.0';
        this.SCRIPT_DEBUG = false;
        this.updateIntervalMs = 1000;

        // Sunny TriPower X-15 15kW Inverter
        this.INV15_MAX_POWER_WATTS = 15000;
        this.INV15_NR_PV_PANELS = 35;
        this.INV15_NR_PV_PANELS_B = 18;
        this.INV15_VOLTAGE_B_OBJ = 'modbus.0.inputRegisters.60960_Measurement_DcMs_Vol_B'/*DC Spannung Eingang B*/
        this.INV15_MODBUS_ID = 'modbus.0';
        this.INV15_CONNECTED_OBJ = this.INV15_MODBUS_ID + '.info.connection';
        this.INV15_CUR_POWER_WATTS_OBJ = this.INV15_MODBUS_ID + '.inputRegisters.60776_Measurement_GridMs_TotW'
        this.inv15_power = 0;

        // Sunny TriPower SmartEnergy 10kW Hybrid Inverter
        this.INV10_MAX_POWER_WATTS = 10000;
        this.INV10_NR_PV_PANELS = 25;
        this.INV10_MODBUS_ID = 'modbus.1';
        this.INV10_CONNECTED_OBJ = this.INV10_MODBUS_ID + '.info.connection';
        this.INV10_CUR_POWER_WATTS_OBJ = this.INV10_MODBUS_ID + '.inputRegisters.60776_Measurement_GridMs_TotW';
        this.inv10_power = 0;

        // PV Forecast from api.forecast.solar
        this.PV_FORECAST_POWER_NOW_OBJ = 'pvforecast.1.summary.power.now';

        // Static PV System Parameters
        this.PV_PEAK_POWER_WATTS = 26400;
        this.PV_GRID_FEEDIN_MAX_WATTS = 13200;
        this.PV_TOTAL_NR_PV_PANELS = this.INV15_NR_PV_PANELS + this.INV10_NR_PV_PANELS;
        this.PV_PANEL_POWER_WATTS = 440;
        this.PV_MANAGER_CONNECTED = 'sma-em.0.info.connection';
        this.PV_GRID_FEEDIN_OBJ = 'sma-em.0.3014001810.psurplus';

        // Configuration
        this.PV_GRID_FEEDIN_TOLERANCE = 250;
        this.PV_MAX_DYNAMICS = 0.2;
        this.PV_MEASUREMENT_DYNAMICS = 0.01;

        this.estimation_mode = PV_POWER_ESTIMATION_MODE.MAX;
        this.mppt = new MpptCurtailmentEstimator(this.SCRIPT_ID, this.INV15_VOLTAGE_B_OBJ, this.INV15_NR_PV_PANELS_B);
        
        this.pv_power = 0;
        this.pv_power_max = 0;
        this.pv_power_min = 0;
        this.pv_power_estimate = 0;
        this.pv_max_power_estimate = 0;
        this.pv_available_excess_power = 0;
        this.feedin_power = 0;
        this.feedin_power_max = 0;
        this.feedin_power_min = 0;
        this.feedin_power_smoothed = 0;
        this.pv_feedin_limit_deviation = 0;
        this.pv_feedin_power_spread = 0;
        this.self_consumption = 0;
        this.self_consumption_max = 0;
        this.self_consumption_min = 0;
        this.self_consumption_spread = 0;
        this.pv_excess_power = 0;
        this.pv_excess_power_smoothed = 0;
        this.pv_shading_loss = 0;

        this.SCRIPT_FEEDIN_MAX_WATTS_OBJ = this.SCRIPT_ID + ".info.feedin_max_watts";
        createState(this.SCRIPT_FEEDIN_MAX_WATTS_OBJ, 0, {read: true, write: false, name: "gridFeedInMaxWatts", type: "number", unit: "W", def: this.PV_GRID_FEEDIN_MAX_WATTS});
        this.SCRIPT_PV_CUR_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_cur_watts";
        createState(this.SCRIPT_PV_CUR_WATTS_OBJ, 0, {read: true, write: false, name: "pvProductionCurrentPower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_FEEDIN_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_feedin_watts";
        createState(this.SCRIPT_PV_FEEDIN_WATTS_OBJ, 0, {read: true, write: false, name: "pvFeedInPower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_FEEDIN_LIMIT_DEVIATION_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_feedin_limit_deviation_watts";
        createState(this.SCRIPT_PV_FEEDIN_LIMIT_DEVIATION_WATTS_OBJ, 0, {read: true, write: false, name: "pvFeedInLimitDeviation", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_FEEDIN_SPREAD_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_feedin_spread_watts";
        createState(this.SCRIPT_PV_FEEDIN_SPREAD_WATTS_OBJ, 0, {read: true, write: false, name: "pvFeedInSpread", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_SHADING_LOSS_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_shading_loss_watts";
        createState(this.SCRIPT_PV_SHADING_LOSS_WATTS_OBJ, 0, {read: true, write: false, name: "pvShadingLossPower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_AVAILABLE_EXCESS_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_available_excess_watts";
        createState(this.SCRIPT_PV_AVAILABLE_EXCESS_WATTS_OBJ, 0, {read: true, write: false, name: "pvProductionAvailableExcessPower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_SELF_CONSUMPTION_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_self_consumption_watts";
        createState(this.SCRIPT_PV_SELF_CONSUMPTION_WATTS_OBJ, 0, {read: true, write: false, name: "pvSelfConsumptionPower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_SELF_CONSUMPTION_SPREAD_OBJ = this.SCRIPT_ID + ".info.pv_self_consumption_spread";
        createState(this.SCRIPT_PV_SELF_CONSUMPTION_SPREAD_OBJ, 0, {read: true, write: false, name: "pvSelfConsumptionSpread", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_ESTIMATE_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_generation_estimate_watts";
        createState(this.SCRIPT_PV_ESTIMATE_WATTS_OBJ, 0, {read: true, write: false, name: "pvGenerationEstimatePower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_ESTIMATE_MAX_WATTS_OBJ = this.SCRIPT_ID + ".info.pv_generation_max_estimate_watts";
        createState(this.SCRIPT_PV_ESTIMATE_MAX_WATTS_OBJ, 0, {read: true, write: false, name: "pvGenerationEstimateMaxPower", type: "number", unit: "W", def: 0});
        this.SCRIPT_PV_ESTIMATION_MODE_OBJ = this.SCRIPT_ID + ".info.pv_estimation_mode";
        createState(this.SCRIPT_PV_ESTIMATION_MODE_OBJ, "MAX", {read: true, write: false, name: "pvPowerEstimationMode", type: "string", def: "MAX"});

        console.log(`Initialized PV System ${this.name} (${this.PV_PEAK_POWER_WATTS} Wp).`)
    }

    getDetails() {
        return (`The name of the system is ${this.name}.`)
    }
    getUpdateIntervalMs() {
        return this.updateIntervalMs;
    }
    
    getSelfConsumption() {
        return this.self_consumption;
    }

    getExcessPower() {
        return this.pv_excess_power_smoothed;
    }

    getAvailableExcessPower() {
        return this.pv_available_excess_power;
    }

    checkReady() {
        if(getState(this.INV10_CONNECTED_OBJ).val 
        && getState(this.INV15_CONNECTED_OBJ).val
        && getState(this.PV_MANAGER_CONNECTED).val) {
            return true;
        } else {
            return false;
        }
    }

    updateShading() {
        /* The 15kW Inverter should produce more than the 10kW inverter proportional to the number
        of PV Panels on the string. */
        var inv15_potential_pv_production = this.inv10_power * this.INV15_NR_PV_PANELS / this.INV10_NR_PV_PANELS;
        var unshaded_pv_production = this.inv10_power + inv15_potential_pv_production;

        if(unshaded_pv_production > this.pv_power) {
            this.pv_shading_loss = unshaded_pv_production - this.pv_power;
        } else {
            this.pv_shading_loss = 0;
        }

    }

    restartMeasurementPeriod() {
        this.pv_power_max = this.pv_power;
        this.pv_power_min = this.pv_power;

        this.feedin_power_max = this.feedin_power;
        this.feedin_power_min = this.feedin_power;

        this.self_consumption_max = this.self_consumption;
        this.self_consumption_min = this.self_consumption;
    }

    fadeGenerationMax() {
        if(this.pv_power_max > this.pv_power_estimate || this.pv_power_max > this.pv_power_fading_max) {
            this.pv_power_fading_max = this.pv_power_max;
        } else {
            this.pv_power_fading_max = smooth(this.pv_power_fading_max, this.pv_power_max, this.PV_MAX_DYNAMICS);
        }
        return this.pv_power_fading_max;
    }

    isCurtailedFeedInValue(feedin_power) {
        if(feedin_power > this.PV_GRID_FEEDIN_MAX_WATTS - this.PV_GRID_FEEDIN_TOLERANCE) {
            return true;
        } 
        return false;
    }

    isCurtailed() {
        return this.isCurtailedFeedInValue(this.feedin_power_smoothed);
    }

    estimateMaxPotentialPower() {
        this.updateShading();
        this.fadeGenerationMax();

        var pv_forecast = getState(this.PV_FORECAST_POWER_NOW_OBJ).val;
        pv_forecast -= this.pv_shading_loss;
        this.pv_max_power_estimate = pv_forecast;
        if(this.isCurtailed()) {
            // We are being curtailed
            if(this.pv_power_max > pv_forecast) {
                // We have observed higher PV power in this period - so we know we can at least produce that
                this.pv_max_power_estimate = this.pv_power_max;
            }
            if(this.pv_power_fading_max > this.pv_max_power_estimate) {
                // We have observed higher PV power earlier, but faded by time since then. 
                // We trust it more than the current forecast or max if it is higher.
                this.pv_max_power_estimate = this.pv_power_fading_max;
            }
        } else {
            // Generation not curtailed because feed-in limit not reached
            this.pv_max_power_estimate = this.pv_power;
        }
        return this.pv_max_power_estimate;
    }

    setEstimationMode(new_mode) {
        var old_mode = this.estimation_mode;
        if(new_mode != old_mode) {
            console.log("Changing estimation mode from " + old_mode + " to " + new_mode +".");
            this.estimation_mode = new_mode;
            setState(this.SCRIPT_PV_ESTIMATION_MODE_OBJ, this.estimation_mode, true);
        }
    }
    
    estimatePotentialPower() 
    {
        this.mppt.updateEstimation(this.isCurtailed(), this.pv_power);
        
        if(!this.mppt.estimateIsStale()) {
            this.setEstimationMode(PV_POWER_ESTIMATION_MODE.MPPT);
            this.pv_power_estimate = this.mppt.getPower();
        } else {
            // If the MPPT estimate is stale (e.g. system is curtailed for a long time,
            // resort to an optimistic max etimate of maximum power to probe the limits
            this.setEstimationMode(PV_POWER_ESTIMATION_MODE.MAX);
            this.pv_power_estimate = this.estimateMaxPotentialPower(); 
        }

        return this.pv_power_estimate;
    }

    updateEstimation() {
        var potential_pv_power = this.estimatePotentialPower();

        // The estimate guarantees that the potential is always higher than the actual
        // and therefore the unused potential is always >= 0
        var unused_potential_power = potential_pv_power - this.pv_power;

        // Correct the unused potential power by the feed-in above or below the limit.
        // If above, the PV system will regulate down the inverter and the deviation become available as 
        // additional potential.
        // If below, we are either not curtailed (negative excess power) or the PV system will regulate up,
        // subtracting from the currently measured potential excess.
        this.pv_excess_power = unused_potential_power + this.pv_feedin_limit_deviation;
        this.pv_excess_power_smoothed = smooth(this.pv_excess_power_smoothed, this.pv_excess_power, this.PV_MEASUREMENT_DYNAMICS)

       // TODO: Calculate real available excess power including controlled load power (Object oriented)

        // At the end of the update we reset the min/max values for the next period
        this.restartMeasurementPeriod();
    }

    process() {
        this.inv10_power = getState(this.INV10_CUR_POWER_WATTS_OBJ).val;
        this.inv15_power = getState(this.INV15_CUR_POWER_WATTS_OBJ).val;

        this.feedin_power = getState(this.PV_GRID_FEEDIN_OBJ).val;
        this.feedin_power_max = max(this.feedin_power, this.feedin_power_max);
        this.feedin_power_min = min(this.feedin_power, this.feedin_power_min);
        this.pv_feedin_limit_deviation = this.feedin_power - this.PV_GRID_FEEDIN_MAX_WATTS;
        this.feedin_power_smoothed = smooth(this.feedin_power_smoothed, this.feedin_power, this.PV_MEASUREMENT_DYNAMICS);
        
        this.pv_power = this.inv10_power + this.inv15_power;
        this.pv_power_max = max(this.pv_power, this.pv_power_max);
        this.pv_power_min = min(this.pv_power, this.pv_power_min);

        this.self_consumption = this.pv_power - this.feedin_power;
        this.self_consumption_max = max(this.self_consumption, this.self_consumption_max);
        this.self_consumption_min = min(this.self_consumption, this.self_consumption_min);

        this.mppt.process(this.isCurtailedFeedInValue(this.feedin_power), this.pv_power);
        this.updateEstimation();
    }

    writeState() {
        setState(this.SCRIPT_PV_FEEDIN_WATTS_OBJ, this.feedin_power, true);
        setState(this.SCRIPT_PV_CUR_WATTS_OBJ, this.pv_power, true);
        setState(this.SCRIPT_PV_FEEDIN_LIMIT_DEVIATION_WATTS_OBJ, this.pv_feedin_limit_deviation, true);
        setState(this.SCRIPT_PV_SELF_CONSUMPTION_WATTS_OBJ, this.self_consumption, true);
        this.pv_feedin_power_spread = this.feedin_power_max - this.feedin_power_min;
        setState(this.SCRIPT_PV_FEEDIN_SPREAD_WATTS_OBJ, this.pv_feedin_power_spread, true);
        this.self_consumption_spread = this.self_consumption_max - this.self_consumption_min;
        setState(this.SCRIPT_PV_SELF_CONSUMPTION_SPREAD_OBJ, this.self_consumption_spread, true);

        setState(this.SCRIPT_PV_SHADING_LOSS_WATTS_OBJ, this.pv_shading_loss, true);
        setState(this.SCRIPT_PV_ESTIMATE_MAX_WATTS_OBJ, this.pv_max_power_estimate, true);
        setState(this.SCRIPT_PV_ESTIMATE_WATTS_OBJ, this.pv_power_estimate, true);

        // For the sake of graphing, we floor the excess power at 0
        this.pv_available_excess_power = this.pv_excess_power > 0 ? this.pv_excess_power : 0;
        setState(this.SCRIPT_PV_AVAILABLE_EXCESS_WATTS_OBJ, this.pv_available_excess_power, true);

        this.mppt.writeState();
    }
}