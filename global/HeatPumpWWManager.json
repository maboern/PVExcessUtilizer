/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
/*
Strategy: Excess
Mode: Efficient, Buffering (once boiler not feasible anymore)
EMI Setting: MaxBuffer

Strategy: Surplus
Mode: Efficient, Buffering (once required = remaining + 1h OR if excess)
EMI Setting: MaxBuffer

Strategy: Greedy
Mode: Modulated, Buffering (if high surplus)
EMI Setting: MaxBuffer
*/
const HEATPUMP_STRATEGY = Object.freeze({
    PASSIVE : "PASSIVE",  // Nothing to actively manage for the heatpump / boiler. This is the default.
    GREEDY : "GREEDY", // Use surplus as available while staying in an efficient regime.
    SURPLUS : "SURPLUS", // Run economic in the morning, use potential excess over noon and fill buffers with surplus before evening.
    EXCESS : "EXCESS", // Only use excess solar energy (via Boiler load) to make warm water
});

class HeatPumpWWManager {
    constructor(root_obj, heatpump, pv_forecast) {
        this.root_obj = root_obj + ".heatpump";
        this.heatpump = heatpump;
        this.pv_forecast = pv_forecast;
        this.DEBUG = false;

        this.strategy = HEATPUMP_STRATEGY.PASSIVE;
        this.strategy_chosen = false;
        this.warmwater_mode = HEATPUMP_MODE.PASSIVE;
        this.emi_settings = new HeatPumpEmiSettings(HEATPUMP_EMI_SETTINGS.MAX_BUFFER, this.root_obj);

        this.remaining_boiler_excess_time = 0;
        this.remaining_warmwater_surplus_time = 0;

        this.excess_load_grace_period_mins = 0; // Grace period / tolerance for switching on loads before the excess energy window passes
        this.surplus_load_grace_period_mins = 60; // Grace period / tolerance for switching on loads before the surplus energy window passes
        this.surplus_buffering_latest_start_hours = 16; // The latest time when we want to start surplus buffering before the evening consumption peak starts
        
        this.STRATEGY_OBJ = this.root_obj + ".strategy";
        createState(this.STRATEGY_OBJ, this.strategy, {read: true, write: false, name: "Strategy", type: "string", def: "UNKNOWN"});
        
        this.restoreState();
        this.updateState();
        setTimeout(() => this.reportStatus(), 5000);
    }

    restoreState() {
        this.strategy = getState(this.STRATEGY_OBJ).val;
        this.strategy_chosen = isToday(getState(this.STRATEGY_OBJ).ts);
        this.emi_settings.apply(HEATPUMP_EMI_SETTINGS.MAX_BUFFER, false);
        //this.setStrategy(HEATPUMP_STRATEGY.SURPLUS);
        console.log("Restored from state: Strategy = " + this.strategy + "");
    }
    getCurrentPower() { return this.heatpump.getCurrentWarmWaterPower(); }
    setWarmWaterMode(new_mode, reason) {
        if(new_mode != this.warmwater_mode) {
            this.warmwater_mode = new_mode;
            this.resetWarmWaterTarget();
            let reason_suffix = '.';
            if(reason) { reason_suffix = " because of " + reason + "."; }
            console.log("Changing Heatpump WarmWater mode to " + new_mode + reason_suffix);
        }
        this.updateState();
    }
    getWarmWaterMode() { return this.warmwater_mode; }
    resetWarmWaterTarget() { this.heatpump.setWarmWaterTarget(HeatPumpMode.getDefaultTargetSettings(this.warmwater_mode).getWarmWaterTemp()); }

    chooseStrategyIfNecessary() {
        let now = new Date();
        if(!this.strategy_chosen && now.getHours() >= 7) {
            console.log("Choosing Strategy for today.");
            this.chooseStrategy();
        }
    }
    
    chooseStrategy() {
        this.updateState();
        this.reportStatus();
        if(this.checkExcessBoilerOnlyFeasible()) {
            this.setStrategy(HEATPUMP_STRATEGY.EXCESS);
        } else if(this.checkSurplusOnlyFeasible()) {
            this.setStrategy(HEATPUMP_STRATEGY.SURPLUS);
        } else {
            this.setStrategy(HEATPUMP_STRATEGY.GREEDY);
        }
        this.strategy_chosen = true;
    }

    updateAtSunrise() {
        this.updateState();
        this.chooseStrategy();
        // We need a write of the Strategy object once a day to refresh the state timestamp.
        setState(this.STRATEGY_OBJ, this.strategy, true);
    }

    reportStatus() {
        let status = "HP WW STATUS (" + this.strategy + ":" + this.getWarmWaterMode() + ") | ";
        status += "DEMAND: " + this.heatpump.getRequiredWarmWaterRunTimeToMaxBuffer() + "m/" + this.heatpump.getRequiredBoilerRunTimeToMaxBuffer() + "m";
        
        if(this.remaining_boiler_excess_time > 0) {
            status += " | EXCESS (Boiler): " + this.remaining_boiler_excess_time + "m";
        }
        status += " | SURPLUS: " + this.remaining_warmwater_surplus_time + "m";
        console.log(status);
    }

    updateHourly() {
        this.chooseStrategyIfNecessary();
        this.reportStatus();
        if(this.DEBUG) {console.log("Last hour average power: " + this.pv_forecast.getLastHourAverageMeasuredPower() + "W");}
    }

    setStrategy(new_strategy) {
        if(this.strategy != new_strategy || !this.strategy_chosen) {
            this.strategy = new_strategy;
            setState(this.STRATEGY_OBJ, this.strategy, true);
            console.log("Set strategy to " + this.strategy + ".");
        }
    }

    checkExcessBoilerOnlyFeasible() {
        // Assume that the heating by heatpump (with low power) will anyway still fit after the boiler heating.
        return this.heatpump.getRequiredBoilerRunTimeToMaxBuffer() + this.excess_load_grace_period_mins <= this.remaining_boiler_excess_time;
    }

    doStartWarmWaterExcessHeatPumpBufferingNow() { return isAfternoon() && !this.checkWarmWaterExcessHeatPumpFeasible(); }
    checkWarmWaterExcessHeatPumpFeasible() {
        // Assume that the heating by heatpump (with low power) will anyway still fit after the boiler heating.
        return this.heatpump.getRequiredWarmWaterRunTimeToMaxBuffer() + this.excess_load_grace_period_mins <= this.remaining_warmwater_excess_time;
    }
    
    isWarmWaterBufferingComplete() {
        return this.heatpump.hasReachedMaxBufferWarmWaterTemp() || 
                this.pv_forecast.estimateRemainingSurplusToday(0) == 0;
    }

    mustStartWarmWaterSurplusBufferingNow() {   
        let now = new Date();
        let time_to_start = isAfternoon() && !this.checkSurplusOnlyFeasible();
        let latest_time_to_start = now.getHours() >= this.surplus_buffering_latest_start_hours;
        let necessary_to_start = this.heatpump.getWarmWaterTemp() < DEFAULT_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp();
        return (time_to_start || latest_time_to_start) && (necessary_to_start); 
    }

    doStartForecastBasedWarmWaterSurplusBuffering() {   
        let surplus_expected = this.pv_forecast.upcomingSurplusForecasted(30, this.heatpump.getExpectedWarmWaterPower(), 2);
        let high_surplus_expected = this.pv_forecast.upcomingSurplusForecasted(30, this.heatpump.getExpectedWarmWaterPower(), 3);
        let peak_soon = this.pv_forecast.getSecondsAfterPeakTime() > -45*60; // Forecasted peak within the next 45 Minutes
        let after_peak = this.pv_forecast.getSecondsAfterPeakTime() > 0;
        let can_start = (peak_soon || after_peak) && surplus_expected;
        let necessary_to_start = this.heatpump.getWarmWaterTemp() < DEFAULT_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp();
        return (can_start) && (necessary_to_start || high_surplus_expected); 
    }

    checkSurplusOnlyFeasible() {
        let required_runtime = this.heatpump.getRequiredWarmWaterRunTimeToMaxBuffer();
        let remaining_time = this.remaining_warmwater_surplus_time;
        return (required_runtime + this.surplus_load_grace_period_mins <= remaining_time);
    }

    calculateWarmWaterEveningBoost() {
        // Decrease the "cost" of warmwater buffering in the evening to encourage
        // buffering with only partial surplus
        const MAX_GRIDPOWER_FRACTION = 0.75;  // We want at least 25% surplus for buffering
        let desired_warmwater_temp_boost = DEFAULT_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp() - this.heatpump.getWarmWaterTemp();
        let gridpower_fraction = MAX_GRIDPOWER_FRACTION * (desired_warmwater_temp_boost / 10);
        let max_boost_watts = this.heatpump.getExpectedWarmWaterPower() * gridpower_fraction; 

        let evening_boost_necessary = this.heatpump.getWarmWaterTemp() < DEFAULT_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp();
        if(evening_boost_necessary) {
            let time_since_peak_secs = this.pv_forecast.getSecondsAfterPeakTime();
            let pv_power_remaining_secs = this.pv_forecast.estimateRemainingSurplusToday(0)*60;
            if(time_since_peak_secs > 0) {
                let pv_time_after_peak = time_since_peak_secs + pv_power_remaining_secs;
                let time_after_peak_fraction = time_since_peak_secs / pv_time_after_peak;
                return time_after_peak_fraction * max_boost_watts;
            } 
        }
        return 0;
    }

     doStartOpportunisticWarmWaterExcessBuffering(min_power) {
        let is_allowed_to_start = this.heatpump.isWarmWaterAllowedToStart();
        let enough_power_now = min_power > this.heatpump.getExpectedWarmWaterPower();
        let enough_power_soon = this.pv_forecast.upcomingSurplusForecasted(this.heatpump.getRequiredWarmWaterRunTimeToMaxBuffer(),
                                                                this.heatpump.getExpectedWarmWaterPower(), 2);
        return is_allowed_to_start && enough_power_now && enough_power_soon && !this.isWarmWaterBufferingComplete(); 
    }
    canContinueWarmWaterBuffering(max_power) {
        let is_ww_on = this.heatpump.isWarmWaterOn(); 
        let is_heating_finishing = this.heatpump.isHeatingOn() && this.heatpump.isHeatingBufferTempAtEfficientMax();
        let is_allowed_to_start = this.heatpump.isWarmWaterAllowedToStart();
        let can_continue = max_power >= this.heatpump.getExpectedWarmWaterPower();
        let can_continue_after_heating = is_heating_finishing && is_allowed_to_start && can_continue;
        return (is_ww_on || can_continue_after_heating) && can_continue;
    }
    mayContinueWarmWaterBuffering() {
        // In order to minimize the number of compressor starts in summer, keep the heatpump
        // filling the warm water buffer while we have surplus power. In winter, keep running
        // unless heating is ready to run as well.
        return this.heatpump.isWarmWaterOn() &&
            (this.heatpump.isInSummerMode() || !(this.heatpump.getRequestedHeatingPower() > 0));
    }
    doStartLowTempWarmWaterBuffering() {
        // If the warmwater temperature goes below the set ECO temperatures minus Hysteresis, the heatpump will automatically
        // start it. But it appears that if that happens, the heatpump will always only warm to the set COMFORT temperature
        // independent of the set EMI temperature and the EMI signals. Causing a second run to be necessary to later or directly
        // afterwards heat to the desired buffer temperature. To avoid this, we do front-running and start it with EMI before
        // the heat pump starts itself.
        // TBC: It appears that this effect (only heating to COMFORT) also occurs when the heat pump is triggered with EMI
        // but below the ECO Temperature (w/o hysteresis). 
        const WW_HYSTERESIS_FUDGE = 1.5;
        let low_temp_threshold = this.heatpump.getWarmWaterEcoTemp(); 
        if(!isAfternoon()) {
            // In the morning, allow to get the temperature lower causing a potential second run in the afternoon
            low_temp_threshold -= this.heatpump.getWarmWaterHysteresis() - WW_HYSTERESIS_FUDGE;
        }
        return this.heatpump.getWarmWaterTemp() <= low_temp_threshold;
    }
    doStartOpportunisticWarmWaterSurplusBuffering(min_surplus_power) {
        const POWER_RESERVE_FACTOR = 2;
        let is_allowed_to_start = this.heatpump.isWarmWaterAllowedToStart();
        let enough_power_now = min_surplus_power > this.heatpump.getExpectedWarmWaterPower() * POWER_RESERVE_FACTOR;
        let is_after_forecasted_peak = (this.pv_forecast.getSecondsAfterPeakTime() > 0);

        return is_allowed_to_start && enough_power_now && is_after_forecasted_peak;
    }

   controlStrategyGreedyWarmWater(surplus, excess) {
        let evening_boost = this.calculateWarmWaterEveningBoost();
        let min_surplus_power = surplus.tail(60).percentile(20) + evening_boost; 
        let max_surplus_power = Math.max(surplus.percentile(75), min_surplus_power) + evening_boost;

        if(this.isWarmWaterBufferingComplete()) {
            this.setWarmWaterMode(HEATPUMP_MODE.PASSIVE, "warmwater buffering complete");
        } else if(this.doStartOpportunisticWarmWaterSurplusBuffering(min_surplus_power) || 
           this.canContinueWarmWaterBuffering(max_surplus_power)) {
            // Opportunistic Buffering if there is surplus. To avoid unnecessary heatpump starts,
            // do not stop once there is no more surplus but instead eat partially into grid energy.
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "opportunistic Surplus Buffering" + ((evening_boost > 0) ? (" (Boost: " + evening_boost + "W)") : 0));
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        } else if(this.doStartLowTempWarmWaterBuffering()) {
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "low Temperature Buffering");
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        } else {
            this.setWarmWaterMode(HEATPUMP_MODE.PASSIVE, "no surplus power available");
            this.heatpump.controlWarmWaterPassive(max_surplus_power);
        }
    }

    controlStrategySurplusWarmWater(surplus, excess) {   
        let evening_boost = this.calculateWarmWaterEveningBoost();
        let min_surplus_power = Math.min(surplus.percentile(20), surplus.tail(60).percentile(20)) + evening_boost;
        let max_surplus_power = Math.max(surplus.tail(2*60).percentile(80), min_surplus_power) + evening_boost;
        let min_excess_power = excess.tail(60).percentile(30);
        let max_excess_power = Math.max(excess.tail(60).percentile(90), min_excess_power);
        
        if(this.isWarmWaterBufferingComplete()) {
            this.setWarmWaterMode(HEATPUMP_MODE.PASSIVE, "warmwater buffering complete");
        } else if(this.doStartOpportunisticWarmWaterExcessBuffering(min_excess_power) || 
           this.canContinueWarmWaterBuffering(max_excess_power)) {
            // Opportunistic Buffering if there is excess. To avoid unnecessary heatpump starts,
            // do not stop once there is no more excess but instead eat into surplus.
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "opportunistic Excess Buffering");
            this.heatpump.controlWarmWater(min_excess_power, max_surplus_power);
        } else if(this.doStartLowTempWarmWaterBuffering()) {
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "low Temperature Buffering");
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        } else if(this.mayContinueWarmWaterBuffering()) {
            // Keep heatpump running if already started
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "WarmWater already running");
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        }  else if(this.doStartForecastBasedWarmWaterSurplusBuffering()) {
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "forecast-based Surplus Buffering");
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        } else if(this.checkSurplusOnlyFeasible()) {
            this.setWarmWaterMode(HEATPUMP_MODE.PASSIVE, "waiting for time to start surplus buffering");
        } else if(this.mustStartWarmWaterSurplusBufferingNow()) {
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "it is time to start buffering surplus now");
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        } else {
            console.log("Strategy SURPLUS not feasible anymore - changing.");
            this.chooseStrategy();
        }
    }

    controlStrategyExcessWarmWater(surplus, excess) {
        let min_excess_power = Math.min(excess.tail(5*60).percentile(50), excess.tail(60).percentile(25));
        let max_excess_power = Math.max(excess.tail(2*60).percentile(90), min_excess_power);
        let min_surplus_power = Math.min(surplus.percentile(20), surplus.tail(60).percentile(20));
        let max_surplus_power = Math.max(surplus.tail(2*60).percentile(80), min_surplus_power);
        
        if(this.isWarmWaterBufferingComplete()) {
            this.setWarmWaterMode(HEATPUMP_MODE.PASSIVE, "warmwater buffering complete");
        } else if(this.mayContinueWarmWaterBuffering()) {
            // To avoid unnecessary heatpump starts, do not stop  and once there is no more excess 
            // eat into surplus. Never start the heatpump
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "WarmWater already running");
            this.heatpump.controlWarmWater(min_excess_power, max_surplus_power);
        } else if(this.doStartLowTempWarmWaterBuffering()) {
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "low Temperature Buffering");
            this.heatpump.controlWarmWater(min_surplus_power, max_surplus_power);
        } else if(this.checkExcessBoilerOnlyFeasible()) {
            // Try to get by with only using the electric boiler for warmwater
            // while keeping heating efficient
            this.setWarmWaterMode(HEATPUMP_MODE.PASSIVE, "attempting to warm water with Boiler only");
        } else if(this.doStartWarmWaterExcessHeatPumpBufferingNow()) {
            this.setWarmWaterMode(HEATPUMP_MODE.BUFFERING, "attempting to buffer with remaining excess power");
            this.heatpump.controlWarmWater(min_excess_power, max_excess_power);
        } else {
            console.log("Strategy EXCESS not feasible anymore - changing.");
            this.chooseStrategy();
        }
    }

    updateState() {
        let target_ww_temp = MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp();
 
        this.remaining_boiler_excess_time = this.pv_forecast.estimateRemainingExcessToday(this.heatpump.getExpectedBoilerPower());
        this.remaining_warmwater_excess_time = this.pv_forecast.estimateRemainingExcessToday(this.heatpump.estimateExpectedWarmWaterPowerAtTemp(target_ww_temp));
        this.remaining_warmwater_surplus_time = this.pv_forecast.estimateRemainingSurplusToday(this.heatpump.estimateExpectedWarmWaterPowerAtTemp(target_ww_temp));

        this.strategy_chosen = isToday(getState(this.STRATEGY_OBJ).ts);
    }
    
    control(surplus, excess) {
        this.updateState();
        switch(this.strategy) {
            case HEATPUMP_STRATEGY.PASSIVE:
                break; // Nothing to control when passive.
            case HEATPUMP_STRATEGY.SURPLUS:
                this.controlStrategySurplusWarmWater(surplus, excess);
                break;
            case HEATPUMP_STRATEGY.GREEDY:
                this.controlStrategyGreedyWarmWater(surplus, excess);
                break;
            case HEATPUMP_STRATEGY.EXCESS:
                this.controlStrategyExcessWarmWater(surplus, excess);
                break;
            default:
                console.error("Invalid strategy: " + this.strategy);
                this.chooseStrategy();
        }
    }
}