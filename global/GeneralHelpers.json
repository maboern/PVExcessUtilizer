/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
/**
 * Checks if a a given state or part of state is existing.
 * This is a workaround, as getObject() or getState() throw warnings in the log.
**/
function getStateIfExisting(obj, fallback_value) {
    const INFINITE_AGE = 99999999999999;
    return getStateIfExistingWithMaxAge(obj, INFINITE_AGE, fallback_value);
}

function getStateIfExistingWithMaxAge(obj, max_age_s, fallback_value) { 
    if(existsState(obj)) {
        let state = getState(obj);
        if(state && (state.ts > Date.now() - max_age_s*1000)) {
            return state.val;
        }
    }
    log("Unable to get state " + obj + " - returning fallback value: " + fallback_value, 'silly');
    return fallback_value;
}

/**
 * Accumulates increments on a daily statistics object with 
 * reset to 0 at midnight.
 */
function updateDailyStat(obj, increment) {
    let state = getState(obj);
    let last_timestamp = state.ts;
    let value = state.val;
    if(!isToday(last_timestamp)) {
        value = 0;
    }
    value += increment;
    setState(obj, value, true);
    historizeDailyStatValue(obj, value);
    return value;
}

/**
 * Accumulates power on a daily statistics object with 
 * reset to 0 at midnight to a Watthours value
 */
function accumulateDailyEnergyStat(obj, power) {
    let state = getState(obj);
    let last_timestamp = state.ts;
    let value = state.val;
    if(!isToday(last_timestamp)) {
        value = 0;
        last_timestamp = Date.now();
    }
    let time = Date.now() - last_timestamp;
    value += (power * time) / (60*60*1000);
    setState(obj, value, true);
    historizeDailyStatValue(obj, value);
    return value;
}

/**
 * Accumulates power stored on a 1s-sample value RingBuffer object
 * on a daily statistics object with 
 * reset to 0 at midnight to a Watthours value. To reduce unnecessary
 * state updates, writes only once the RingBuffer object is full and
 * each time it wraps again thereafter.
 */
function accumulateDailyEnergyStatBuffered(obj, power_buffer) {
    if(power_buffer.hasJustWrapped()) {
        let energy = power_buffer.sum() / (60*60);
        return updateDailyStat(obj, energy);
    }
    return getStateIfExisting(obj);
}


function historizeDailyStatValue(obj, value) {
    let midday = new Date().setHours(12, 0, 0, 0);
    sendTo('influxdb.0', 'storeState', {
            id: obj,
            state: {
                ts: midday,
                val: value,
                ack: true,
                from: 'javascript daily stat'
            }
        }
    );
}

class SignalDebouncer {
    constructor(initial_value, slack) {
        this.value = initial_value;
        this.last_value = initial_value;
        this.slack = slack;
    }
    updateValue(value) {
        this.last_value = value;
        if(Math.abs(value - this.value) >= this.slack) {
            this.value = value;
        }
    }
    debounced() { return this.value; }
    raw() { return this.last_value; }
}

class StateSignalDebouncer extends SignalDebouncer {
    constructor(initial_value, slack, obj) {
        super(initial_value, slack);
        this.obj = obj;
    }

    update() {
        let value = getStateIfExisting(this.obj, this.last_value);
        super.updateValue(value);
    }
}