/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
class HeatPumpHeatManager {
    constructor(root_obj, heatpump, pv_forecast) {
        this.root_obj = root_obj + ".heatpump";
        this.heatpump = heatpump;
        this.stats = this.heatpump.getStats();
        this.pv_forecast = pv_forecast;
        this.thermostat = new HeatPumpRoomThermostat(this.root_obj, heatpump, pv_forecast);
        this.DEBUG = false;

        this.heating_mode = HEATPUMP_MODE.PASSIVE;
        this.remaining_heating_surplus_time = 0;
        
        this.HEAT_MODE = this.root_obj + ".heat_mode";
        createState(this.HEAT_MODE, 0, {read: true, write: false, name: "Heating Mode", type: "number", min: -1, max: 4, def: 0, states: {0:'PASSIVE', 1:'MODULATED', 2:'EFFICIENT', 3:'BUFFERING', 4:'WARMUP'}});

        this.updateState();
        setTimeout(() => this.updateHourly(), 5000);
    }

    getCurrentPower() { return this.heatpump.getCurrentHeatingPower(); }

    setHeatingMode(new_mode, reason) {
        if(new_mode != this.heating_mode) {
            this.heating_mode = new_mode;
            setState(this.HEAT_MODE, HeatPumpMode.getCode(this.heating_mode), true);
            this.resetHeatingBufferMax();
            let reason_suffix = '.';
            if(reason) { reason_suffix = " because of " + reason + "."; }
            if(!this.stats.isInSummerMode()) {
                console.log("Changing Heatpump Heating mode to " + new_mode + reason_suffix);
            }
        }
        this.updateState();
    }
    getHeatingMode() { return this.heating_mode; } 
    resetHeatingBufferMax() { this.heatpump.setHeatingBufferMax(HeatPumpMode.getDefaultTargetSettings(this.heating_mode).getHeatingBufferTemp()); }

    reportStatus() {
        if(!this.stats.isInSummerMode()) { 
		    let status = "HP HEAT STATUS (" + this.getHeatingMode() + ")";
            status += " | DEMAND: Buffering = " + this.heatpump.getRequiredHeatingRunTimeToMaxBuffer() + "m"; 
            status += ", Warmup = " + round(this.thermostat.estimateWarmupHoursUntilOverheated(), 0.1) + "h";
		    status += " | SURPLUS: " + this.remaining_heating_surplus_time + "m";
			console.log(status);
            this.heatpump.reportStatus();
        }
    }

    updateHourly() {
        this.thermostat.updateHourly();
        if(this.heatpump.isHeatingControllable()) { this.reportStatus(); }
    }
    
    doStartHeatingSurplusBufferingNow(min_power) { 
		let surplus_forecasted = this.pv_forecast.upcomingSurplusForecasted(30,  this.heatpump.getExpectedHeatingPower(), 1);
        let surplus_now = min_power > this.heatpump.getMinHeatingPower();
        if(surplus_forecasted && surplus_now) {
            let required_time = Math.max(this.heatpump.getRequiredHeatingRunTimeToMaxBuffer(), 2*60); // Cannot sustain more than 2h of buffering
            let time_to_start = this.remaining_heating_surplus_time < required_time;
            let necessary_to_start = this.stats.getHeatingBufferTemp() <= DEFAULT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp();
            let heat_consumption_low = true; //this.thermostat.areAllRoomsOverheated();
            return isAfternoon() && time_to_start && necessary_to_start && heat_consumption_low; 
        } else {
            return false;
        }
    }
    canContinueHeatingBuffering(max_power) {
        let is_on = this.heatpump.isHeatingOn(); 
        let is_buffering = this.getHeatingMode() == HEATPUMP_MODE.BUFFERING;
        let can_continue = max_power > this.heatpump.getMinHeatingPower();
        return is_on && is_buffering && can_continue;
    }
    doStartHeatingAfterWarmWater(max_power) {
        let is_heat_on = this.heatpump.isHeatingOn();
        let is_heat_starting = this.heatpump.isHeatingStartingUp();
        let reasonable_to_buffer = this.stats.getHeatingBufferTemp() < Math.min(EFFICIENT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp(), this.heatpump.getTargetHeatingBufferTemp());
        let is_heating_allowed_to_start = this.heatpump.isHeatingAllowedToStart();
        let continue_after_warmwater = this.heatpump.isWarmWaterOn() && reasonable_to_buffer && is_heating_allowed_to_start;
        let can_continue = max_power > this.heatpump.getMinHeatingPower();
        return continue_after_warmwater && can_continue && (!is_heat_on || is_heat_starting);
    }

    doWarmupHeating() {
        let time_to_overheat = this.thermostat.estimateWarmupHoursUntilOverheated()*60;
        let time_to_start = this.remaining_heating_surplus_time < time_to_overheat;
        let not_overheated = !this.thermostat.isAnyRoomAtMaxOverheatedTemp();
        let buffer_not_high = !this.heatpump.isHeatingBufferTempAtEfficientMax();
        return time_to_start && not_overheated && buffer_not_high;
    }

    controlHeating(surplus, excess) {
        let min_surplus_power = surplus.tail(60).percentile(20); 
        let max_surplus_power = Math.max(surplus.percentile(90), Math.max(surplus.tail(60).percentile(90), min_surplus_power));
        
        this.thermostat.control(min_surplus_power, max_surplus_power);

        if(this.stats.isInSummerMode()) {
            this.setHeatingMode(HEATPUMP_MODE.PASSIVE, "in summer mode.");
            this.heatpump.controlPassiveHeating();
        } else if(this.pv_forecast.isNight()) {
            this.setHeatingMode(HEATPUMP_MODE.PASSIVE, "night time.");
            this.heatpump.controlPassiveHeating();
        } else if(this.doStartHeatingSurplusBufferingNow(min_surplus_power) || this.canContinueHeatingBuffering(max_surplus_power)) { 
            this.setHeatingMode(HEATPUMP_MODE.BUFFERING, "it is time to start buffering surplus now");
            this.heatpump.controlMaxBufferingHeating(min_surplus_power, max_surplus_power);
        } else if(this.doStartHeatingAfterWarmWater(max_surplus_power)) {
            this.heatpump.controlMaxBufferingHeating(min_surplus_power, max_surplus_power);
        } else if(this.pv_forecast.upcomingSurplusForecasted(30,  this.heatpump.getExpectedHeatingPower(), 2)) {
            if(this.doWarmupHeating()) {
                this.setHeatingMode(HEATPUMP_MODE.WARMUP, "expected surplus and warmup necessary.");
                this.heatpump.controlWarmupHeating(min_surplus_power, max_surplus_power); 
            } else {
                this.setHeatingMode(HEATPUMP_MODE.EFFICIENT, "expected surplus and no warmup necessary.");
                this.heatpump.controlEfficientHeating(min_surplus_power, max_surplus_power);
            }
        } else {
            this.setHeatingMode(HEATPUMP_MODE.MODULATED, "greedy heating.");
            this.heatpump.controlModulatedHeating(min_surplus_power, max_surplus_power);
        }
    }

    calculatePotentialExcessControlPower() {
        if(this.heatpump.isHeatingOn() && this.getHeatingMode() == HEATPUMP_MODE.EFFICIENT) {
            let potential_headroom = this.heatpump.getMaxHeatingPower() - this.heatpump.getMinHeatingPower();
            return potential_headroom;
        } else {
            return 0;
        }
    }
    setExcessControlPower(control_power) { this.excess_control_power = control_power; }
    getExcessControlPower() { 
        if(this.heatpump.isHeatingOn() && this.getHeatingMode() == HEATPUMP_MODE.EFFICIENT) {
            return this.heatpump.getCurrentHeatingPower() - this.heatpump.getMinHeatingPower();
        } else {
            return 0;
        }
    }

    updateState() {
        let target_heating_temp = this.thermostat.getEfficientTargetHeatingBufferTemp();
        this.heatpump.setEquilibriumHeatingBufferTarget(target_heating_temp);
        this.remaining_heating_surplus_time = this.pv_forecast.estimateRemainingSurplusToday(this.heatpump.estimateExpectedHeatingPower(target_heating_temp));
    }
    
    control(surplus, excess) {
        this.updateState();
        this.controlHeating(surplus, excess);
    }

}