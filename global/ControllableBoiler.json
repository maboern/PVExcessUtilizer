/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/
class ControllableBoiler extends ControllableLoad {
    constructor(script_id, name) {
        super(script_id, name, CONTROLLABLE_LOAD_TYPE.BOILER);

        this.expected_power = 4000;
        this.load_hysteresis_power = 250;
        this.is_connected_obj = 'modbus.2.info.connection';;
        this.switch_obj = 'modbus.2.coils.0_DO-00';
        this.startup_time_ms = 5 * 1000;
        this.max_day_runtime_secs = 4*60*60;
        this.boiler_temperature = 0;
        this.boiler_max_temperature = 55; // Heating element stops at ~55Â°C
        this.min_break_after_self_shutoff_secs = 45*60; 

        this.boiler_temperature_sensor_obj = 'stiebel-isg.0.info.ANLAGE.WARMWASSER.ISTTEMPERATUR';

        console.log("Initialized " + this.toString());
    }

    toString() {
        return super.toString() + ": " + this.expected_power + "W";
    }

    getTemperature() {
        return this.boiler_temperature;
    }

    updateTemperature() {
        var temp_obj = getState(this.boiler_temperature_sensor_obj);
        if(temp_obj && temp_obj.ts > Date.now() - 3*60*60*1000) {
            this.boiler_temperature = temp_obj.val;
        }
    }
    hasReachedMaxTemperature() {
        this.updateTemperature();
        return this.boiler_temperature >= this.boiler_max_temperature;
    }

    allowedToRunAgainAfterSelfShutoff() {
        // Allow the water in the boiler to organize itself into layers before starting heating element again.
        return (this.self_shutoff_at == 0 || ((Date.now() - this.self_shutoff_at) > this.min_break_after_self_shutoff_secs * 1000));
    } 

    allowedToRun() {
        // Not allowed to run if it has shut itself off (due to temperature being reached) today
        return (super.allowedToRun() && !this.hasReachedMaxTemperature() && this.allowedToRunAgainAfterSelfShutoff())
    }
}