/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/

const SPECIFIC_HEAT_CAPACITY_WATER_KWH = 4.186 / 3600; // 4.186 kJ/kg·°C; 3600 kJ/kWh

class HeatPump {
      constructor(root_obj, boiler) {
        this.root_obj = root_obj + ".heatpump";
        this.semp_client = new HeatPumpSempClient(this.root_obj);
        this.boiler = boiler;
        this.stats = new HeatPumpStats(root_obj, this.semp_client);
        this.DEBUG = false;

        this.operating_mode_obj = 'stiebel-isg.0.Start.val1';
        this.ww_output_power_kw_summer_obj = 'stiebel-isg.0.settings.WARMWASSER.WW LEISTUNG WP.val1126';
        this.ww_output_power_kw_winter_obj = 'stiebel-isg.0.settings.WARMWASSER.WW LEISTUNG WP.val1127';
        this.ww_eco_temp_obj = 'stiebel-isg.0.settings.WARMWASSER.WARMWASSERTEMPERATUREN.val11019';
        this.ww_hysteresis_obj = 'stiebel-isg.0.settings.WARMWASSER.GRUNDEINSTELLUNG.val120';

        this.required_boiler_runtime = 0;
        this.required_warmwater_runtime = 0;
        this.required_heating_runtime = 0;
        this.required_equilibrium_heating_power = 0;

        this.min_heatpump_runtime_mins = 15; // Do not start the heatpump if it is expected to run less than that time.
        this.min_heating_pause_secs = 10*60; // Grace period between heating runs
        this.heating_buffer_volume = 400; // 400 l
        this.warmwater_output_power = 7000; // The heatpump works in a constant output (heat) power regime with variable electric power input
        this.heating_buffering_input_power_target = 2000; // The expected "norm" power when heating buffering.
        this.heating_buffering_input_power_max = 3000; // The "maximum" power when heating buffering
        this.heating_expected_power = 1500;
        this.warmwater_expected_power = 2500; 

        this.warmwater_target = EFFICIENT_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp();
        this.heating_buffer_max = EFFICIENT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp();

        this.modulation_recommended = 0;
        this.modulation_temp_offset = 0;
        this.modulation_availability_offset = 0;
        
        this.EFFICIENCY_FACTOR = this.root_obj + ".efficiency";
        createState(this.EFFICIENCY_FACTOR, 1, {read: true, write: false, name: "Heatpump Efficency Factor", type: "number", def: 1});
        this.ESTIMATED_WARMWATER_POWER = this.root_obj + ".estimated_warmwater_power";
        createState(this.ESTIMATED_WARMWATER_POWER, 0, {read: true, write: false, name: "Estimated WarmWater Power", type: "number", unit: "W", def: 0});
        this.EMI_MODE = this.root_obj + ".emi_mode";
        createState(this.EMI_MODE, 0, {read: true, write: false, name: "EMI Mode", type: "number", min: 0, max: 3, def: 0, states: {0:'EMI_OK', 1:'EMI_ECO', 2:'EMI_COMFORT', 3:'EMI_HIGH'}});

        this.HEATING_BUFFER_TEMP = this.root_obj + ".heating_buffer_temp";
        createState(this.HEATING_BUFFER_TEMP, 40, {read: true, write: false, name: "Heating Buffer Temperature (corrected)", type: "number", unit: "°C", def: 45});
        this.HEATING_BUFFER_MAX_TEMP = this.root_obj + ".heating_buffer_max_temp";
        createState(this.HEATING_BUFFER_MAX_TEMP, 45, {read: true, write: false, name: "Max Heating Buffer Temperature", type: "number", unit: "°C", def: 45});
        this.HEATING_BUFFER_TEMP_OVER = this.root_obj + ".heating_buffer_temp_overshoot";
        createState(this.HEATING_BUFFER_TEMP_OVER, 0, {read: true, write: false, name: "Heating Buffer Temperature Overshoot", type: "number", unit: "°C", def: 0});
        this.EQUILIBRIUM_HEATING_POWER = this.root_obj + ".equilibrium_heating_power";
        createState(this.EQUILIBRIUM_HEATING_POWER, 0, {read: true, write: false, name: "Required Equilibrium Heating Power", type: "number", unit: "W", def: 0});
        this.MODULATION_RECOMMENDED = this.root_obj + ".modulation_recommended";
        createState(this.MODULATION_RECOMMENDED, 0, {read: true, write: false, name: "Recommended Power Modulation", type: "number", unit: "W", def: 0});
        this.MODULATION_OFFSET_AVAILABILITY = this.root_obj + ".modulation_availability_offset";
        createState(this.MODULATION_OFFSET_AVAILABILITY, 0, {read: true, write: false, name: "Recommended Power Offset Availability", type: "number", unit: "W", def: 0});
        this.MODULATION_OFFSET_TEMPERATURE = this.root_obj + ".modulation_temperature_offset";
        createState(this.MODULATION_OFFSET_TEMPERATURE, 0, {read: true, write: false, name: "Recommended Power Offset Temperature", type: "number", unit: "W", def: 0});

        this.DAY_WARMWATER_ENERGY_OBJ = this.root_obj + ".day_warmwater_energy";
        createState(this.DAY_WARMWATER_ENERGY_OBJ, 0, {read: true, write: false, name: "WarmWater Energy Day", type: "number", unit: "Wh", def: 0});
        this.DAY_HEATING_ENERGY_OBJ = this.root_obj + ".day_heating_energy";
        createState(this.DAY_HEATING_ENERGY_OBJ, 0, {read: true, write: false, name: "Heating Energy Day", type: "number", unit: "Wh", def: 0});

        this.updateState();
    }  
    
    resetOperatingMode() { return this.setOperatingMode(HEATPUMP_OPERATING_MODE.PROGRAM); }
    setOperatingModeWarmWaterOnly() { return this.setOperatingMode(HEATPUMP_OPERATING_MODE.WARMWATER_ONLY);}
    setOperatingMode(mode) { 
        let prev_mode = this.getOperatingMode();
        if(prev_mode != mode) {
            let secs_in_previous_operating_mode = (Date.now() - getState(this.operating_mode_obj).lc)/1000;
            setState(this.operating_mode_obj, mode, false);
            console.log("Set HP Operating Mode to " + HeatPumpOperatingMode.toString(mode) + " after " + Math.round(secs_in_previous_operating_mode/360)/10 + "h in Mode " + HeatPumpOperatingMode.toString(prev_mode) + ".");
            return secs_in_previous_operating_mode; // Return the time the now changed operating mode was active
        }
        return 0;
    }
    getOperatingMode() { return getStateIfExisting(this.operating_mode_obj);}
    isOperatingModeWarmWaterOnly() { return this.getOperatingMode() == HEATPUMP_OPERATING_MODE.WARMWATER_ONLY; }
    getStats() { return this.stats; }
    getWarmWaterEcoTemp() { return getStateIfExisting(this.ww_eco_temp_obj, 42.5);}
    getWarmWaterHysteresis() { return getStateIfExisting(this.ww_hysteresis_obj, 6);}
    getWarmWaterTarget() { return this.warmwater_target; }
    setWarmWaterTarget(temp, reason) {
        if(temp != this.warmwater_target) {
            this.warmwater_target = temp;
            let reason_suffix = '.';
            if(reason) { reason_suffix = " because of " + reason + "."; }
            console.log("Changing target WarmWater temperature to " + temp + "°C" + reason_suffix);
        }
        this.updateState();
    }
    getEmiMode() {
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_OK', null)) { return "EMI_OK";}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_HIGH', null)) { return "EMI_ACTIVE_HIGH";}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_COMFORT', null)) { return "EMI_ACTIVE_COMFORT";}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_ECO', null)) { return "EMI_ACTIVE_ECO";}
        return "UNKNOWN";
    }
    getEmiModeCode() {
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_OK', null)) { return 0;}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_HIGH', null)) { return 3;}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_COMFORT', null)) { return 2;}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_ECO', null)) { return 1;}
        return -1;
    }
    forceEmiModeHigh() {
        // returns true if something changed and no other request should be done this round
        switch(this.getEmiMode()) {
            case "EMI_OK":
                console.log("Forcing EMI Mode High.")
                return this.semp_client.requestHeating(5000, true);
            case "EMI_ACTIVE_COMFORT":
            case "EMI_ACTIVE_ECO":
                // First cancel other EMI modes so we can switch to high
                return this.semp_client.requestHeating(0, true);
            default:
                return false;
        }
    }

    getTargetHeatingBufferTemp() {
        return Math.max(this.stats.getTargetTempHk2(), this.stats.getTargetTempHk3());
    }
    calculateHeatingBufferMaxFromTarget(target_heating_buffer_temp) {
        const HEATING_BUFFER_HYSTERESIS = 5; // Go max 5°C above target temperature
        const LOWEST_HEATING_BUFFER_MAX = 32; // But at least 32°C
        return Math.max(target_heating_buffer_temp + HEATING_BUFFER_HYSTERESIS, LOWEST_HEATING_BUFFER_MAX);
    }
    calculateEfficientHeatingBufferMax() { return this.calculateHeatingBufferMaxFromTarget(this.getTargetHeatingBufferTemp());}
    getHeatingBufferMax() { return this.heating_buffer_max; }
    setHeatingBufferMax(temp, reason) {
        if(temp != this.heating_buffer_max) {
            this.heating_buffer_max = temp;
            let reason_suffix = '.';
            if(reason) { reason_suffix = " because of " + reason + "."; }
            if(this.DEBUG) { console.log("Changing Max Heating Buffer temperature to " + temp + "°C" + reason_suffix); }
        }
        this.updateState();
    }
    getRequestedHeatingPower() { return this.semp_client.getRequestedHeatingPower(); }


    getHeatingBufferTempOvershoot() { return this.stats.getHeatingBufferTemp() - this.getTargetHeatingBufferTemp();   }
    isHeatingBufferTempAtEfficientMax() { return this.stats.getHeatingBufferTemp() - this.calculateEfficientHeatingBufferMax() > 0;}

    estimateCurrentHeatPumpEfficiencyFactor() {
        let ambient_temperature = this.stats.getAmbientTemp(); 
        if(this.isHeatingOn()) {
            return this.estimateHeatPumpEfficiencyFactor(ambient_temperature, this.stats.getHeatingBufferTemp());
        } else if(this.isWarmWaterOn()) {
            return this.estimateHeatPumpEfficiencyFactor(ambient_temperature, this.stats.getWarmWaterTemp());
        } else {
            return 0;
        }
    }

    estimateHeatPumpEfficiencyFactor(ambient_temp, output_temp) {
        // Ambient:        W35           W55
        // 20°C             6.21        3.56
        // 10°C             5.48
        //  7°C             4.72        3.19
        //  2°C             4.00        2.91
        // -7°C             3.00        2.34
        //-15°C             2.67        2.07
        // Approximate with pessimistic values (datasheet does not account for fan/pump/spread)
        const HEATPUMP_SPREAD_DEGREES = 4;

        let temp_delta = output_temp + HEATPUMP_SPREAD_DEGREES - ambient_temp;
        if(temp_delta < 15) { return 6; } else
        if(temp_delta < 25) { return 5 + (25 - temp_delta)/10; } else
        if(temp_delta < 35) { return 4 + (35 - temp_delta)/10; } else 
        if(temp_delta < 45) { return 3 + (45 - temp_delta)/10; } else
        if(temp_delta < 55) { return 2 + (55 - temp_delta)/10; }
        else { return 1; }
    }

    estimateEquilibriumHeatingOutputPower() {
        // Auslegung Heizug: 7.8kW @ -10°C - linear interpolation to 0kW @ +20°C
        let ambient_temperature = this.stats.getAmbientTemp();
        let output_power = 7800 * (30 - (ambient_temperature + 10)) / 30;
        return Math.max(output_power, 0);
    }

    estimateEquilibriumHeatingPower(target_temperature) {
        if(this.stats.isInSummerMode()) { return 0; }
        let ambient_temperature = this.stats.getAmbientTemp();
        let output_power = this.estimateEquilibriumHeatingOutputPower();
        let input_power = output_power / this.estimateHeatPumpEfficiencyFactor(ambient_temperature, target_temperature);
        return input_power;
    }

    estimateExpectedHeatingPower(target_temperature) {
        return Math.max(this.estimateEquilibriumHeatingPower(target_temperature), this.getMinHeatingPower());
    }

    estimateEfficientWarmupInputPower() {
        const EFFICIENT_WARMUP_BOOST_POWER = 1000;
        let efficient_input = this.estimateEquilibriumHeatingPower() + EFFICIENT_WARMUP_BOOST_POWER;
        return limit(this.getMinHeatingPower(), efficient_input, this.heating_buffering_input_power_max)
    }
    estimateEfficientWarmupOutputPower(target_temperature) {
        return this.estimateEfficientWarmupInputPower() * this.estimateHeatPumpEfficiencyFactor(this.stats.getAmbientTemp(), target_temperature);
    }

    estimateExpectedHeatingBufferingOutputPower(target_temperature) {
        // This is a pessimistic estimate, because the heatpump is calculated at the target temperature efficiency factor the whole time
        // while in reality it starts at the efficiency factor of the current temperature.
        let ambient_temperature = this.stats.getAmbientTemp();
        return this.heating_buffering_input_power_target * this.estimateHeatPumpEfficiencyFactor(ambient_temperature, target_temperature);
    }

    estimateHeatingRunMinsRequired(target_temperature) {
        var energy_kwh = this.estimateHeatingEnergyRequired(target_temperature);
        var time_hours = (energy_kwh * 1000) / (this.estimateExpectedHeatingBufferingOutputPower(target_temperature));
        if(this.stats.areHeatingCirculationPumpsOn()) {
            let equilibrium_output_power = this.estimateEquilibriumHeatingOutputPower();
            let equilibrium_energy = equilibrium_output_power * time_hours / 1000;
            time_hours *= 1 + (equilibrium_energy / energy_kwh)
        }
        return Math.round(time_hours * 60);
    }
    
    estimateHeatingEnergyRequired(target_temperature) {
        if(this.stats.isInSummerMode()) { return 0; }
        
        let buffer_temperature = this.stats.getHeatingBufferTemp();
        var temperature_diff = target_temperature - buffer_temperature;
        if(temperature_diff < 0) {
            temperature_diff = 0;
        }
        var boiler_kwh_per_degree = this.heating_buffer_volume * SPECIFIC_HEAT_CAPACITY_WATER_KWH;
        var required_energy_kwh = boiler_kwh_per_degree * temperature_diff;
        if(this.DEBUG) { console.log("Heating Buffer Target: " + target_temperature + "°C, Current: " + buffer_temperature + " => Energy: " + required_energy_kwh + "kWh");}
        return required_energy_kwh;
    }

    estimateExpectedWarmWaterPowerAtTemp(warmwater_temp) {
        let ambient_temperature = this.stats.getAmbientTemp();
        let temperature_delta = warmwater_temp - ambient_temperature;

        // Measured power: 1.5kW@35° 1.9kW@44°, 2.7kW@48°, 5kW@55° (7kW output power, 10°C outside)
        // => 1500W @ 25° delta, 1900W @ 34° delta, 2700W @ 38° delta, 5000W @ 45° delta
        // Linearize between these points

        if(temperature_delta < 25) {
            return 1500;
        } else if(temperature_delta < 34) {
            return 1500 + (temperature_delta - 25) * 44;
        } else if(temperature_delta < 38) {
            return 1900 + (temperature_delta - 34) * 200;
        } else {
            return 2700 + (temperature_delta - 38) * 329;
        }
    }

    estimateWarmWaterRunMinsRequired(target_temperature) {
        var energy_kwh = this.estimateWarmWaterEnergyRequired(target_temperature);
        var time_hours = (energy_kwh * 1000) / (this.warmwater_output_power); 
        return Math.round(time_hours * 60);
    }

    estimateBoilerRunMinsRequired(target_temperature) {
        var energy_kwh = this.estimateWarmWaterEnergyRequired(target_temperature);
        var time_hours = (energy_kwh * 1000) / this.boiler.getExpectedPower();
        return Math.round(time_hours * 60);
    }

    estimateWarmWaterEnergyRequired(target_temperature) {
        var temperature_diff = target_temperature - this.stats.getWarmWaterTemp();
        if(temperature_diff < 0) {
            temperature_diff = 0;
        }
        var kwh_per_degree = this.boiler.getVolume() * SPECIFIC_HEAT_CAPACITY_WATER_KWH;
        var required_energy_kwh = kwh_per_degree * temperature_diff;
        if(this.DEBUG) { console.log("Warm Water Target: " + target_temperature + "°C, Current: " + this.stats.getWarmWaterTemp() + " => Energy: " + required_energy_kwh + "kWh");}
        return required_energy_kwh;
    }

    isWarmWaterAllowedToStart() {  return (this.required_warmwater_runtime >= this.min_heatpump_runtime_mins); }
    isWarmWaterAllowedToStop() { 
        let min_runtime_elapsed = !isNowInTimePeriod(this.semp_client.getWarmWaterStartTimeStamp(), this.min_heatpump_runtime_mins*60*1000);
        return this.semp_client.isWarmWaterControllable() && min_runtime_elapsed; }
    isWarmWaterOn() { return this.semp_client.isWarmWaterOn(); }

    hasHeatingMinPauseElapsed() { return (Date.now() - this.semp_client.getHeatingStopTimeStamp() > this.min_heating_pause_secs);}
    isHeatingAllowedToStart() { return (this.required_heating_runtime >= this.min_heatpump_runtime_mins) && this.hasHeatingMinPauseElapsed() && !this.semp_client.isWarmWaterStartingUp();}
    isHeatingAllowedToStop() { return this.semp_client.isHeatingControllable(); }
    isHeatingOn() { return this.semp_client.isHeatingOn(); }
    isHeatingStartingUp() { return this.semp_client.isHeatingStartingUp();}
    getHeatingStartTimeStamp() { return this.semp_client.getHeatingStartTimeStamp(); }

    isAllowedToStart() { return (this.isWarmWaterAllowedToStart() || this.isHeatingAllowedToStart());  }
    isOn() { return this.isWarmWaterOn() || this.isHeatingOn(); }
    getRequiredWarmWaterRunTimeToMaxBuffer() { return this.estimateWarmWaterRunMinsRequired(MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp());}
    getRequiredBoilerRunTimeToMaxBuffer() { return this.estimateBoilerRunMinsRequired(MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp()); }
    getRequiredHeatingRunTimeToMaxBuffer() { return this.estimateHeatingRunMinsRequired(MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp()); }
    getExpectedWarmWaterPower() { return this.warmwater_expected_power; }
    getExpectedHeatingPower() { return this.heating_expected_power; }
    getMinHeatingPower() { return this.semp_client.getHeatingMinPower(); }
    getMaxHeatingPower() { return this.semp_client.getHeatingMaxPower(); }
    getCurrentPower() { return this.semp_client.getHeatingPower() + this.semp_client.getWarmWaterPower(); }
    getCurrentWarmWaterPower() { return this.semp_client.getWarmWaterPower(); }
    getCurrentHeatingPower() { return this.semp_client.getHeatingPower(); }
    hasReachedWarmWaterTemp() { return this.stats.getWarmWaterTemp() >= this.getWarmWaterTarget(); }
    hasReachedMaxBufferWarmWaterTemp() { return this.stats.getWarmWaterTemp() >= MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp(); }
    hasReachedHeatingBufferTemp() { return this.stats.getHeatingBufferTemp() >= this.getHeatingBufferMax(); }

    controlWarmWaterPassive(max_available_power) { this.controlWarmWater(0, max_available_power); }
    controlWarmWater(min_available_power, max_available_power) {
        let expected_power_consumption = this.isWarmWaterOn() ? this.semp_client.getWarmWaterPower() : this.getExpectedWarmWaterPower();
        
        if(this.DEBUG) { console.log("Expected WW Power: " + expected_power_consumption + "W, Min AV: " + min_available_power + "W, Max AV: " + max_available_power + "W"); }
        if(this.isWarmWaterAllowedToStart() || (this.isWarmWaterOn() && this.semp_client.isWarmWaterControllable())) {
            if(min_available_power >= expected_power_consumption && !this.hasReachedWarmWaterTemp()) {
                if(this.semp_client.requestWarmWater(true, false)) {
                    console.log("Requested WarmWater ON with min power: " + Math.round(min_available_power) + "W / " + expected_power_consumption + "W");
                }
            } 
        }
        this.stopWarmWaterIfNecessary(expected_power_consumption, max_available_power)
    }

    stopWarmWaterIfNecessary(expected_power_consumption, available_power) {
       if(this.isWarmWaterAllowedToStop() && this.isWarmWaterOn()) {
            if(available_power < expected_power_consumption) {
                if(this.semp_client.requestWarmWater(false, false)) {
                    console.log("Requested WarmWater OFF because of low available power: " + Math.round(available_power) + "W / " + Math.round(expected_power_consumption) + "W");
                }
            } else if(this.hasReachedWarmWaterTemp()) {
                if(this.semp_client.requestWarmWater(false, false)) {
                    console.log("Requested WarmWater OFF because of reaching warmwater temp of " + this.getWarmWaterTarget() + "°C");
                }
            }
        }
    }

    controlHeating(min_available_power, max_available_power, recommended_power) {
        this.modulation_recommended = recommended_power;
        let min_heating_power = this.getMinHeatingPower(); 
        if((this.isHeatingAllowedToStart() || this.isHeatingOn()) && this.semp_client.isHeatingControllable()) {
            if(min_available_power >= min_heating_power && !this.hasReachedHeatingBufferTemp() && recommended_power > 0) {
                let requested_power = Math.max(recommended_power, this.semp_client.getHeatingMaxPower());
               /* if(this.forceEmiModeHigh()) { 
                    return; // EMI mode is not yet high - is being forced
                } else */if(this.semp_client.requestHeating(requested_power, false)) {
                    let heating_plan = this.semp_client.isHeatingPlanActive() ? " (Heating Plan: ON)" : "";
                    console.log("Requested Heating ON with power: " + Math.round(requested_power) + "W out of recommended " + Math.round(recommended_power) + "W / " + Math.round(min_heating_power) + "W" + heating_plan);
                }
            } 
        }
        if(this.isHeatingAllowedToStop()) { 
            if(max_available_power < min_heating_power  && !this.isWarmWaterOn()) { // Never cancel Heating request if Warmwater is on
                if(this.semp_client.requestHeating(0, false)) {
                    console.log("Requested Heating OFF because of low available power: " + Math.round(max_available_power) + "W / " + Math.round(min_heating_power) + "W");
                }
            } else if(recommended_power == 0) {
                if(this.semp_client.requestHeating(0, false)) {
                    console.log("Requested Heating OFF because of recommended power indicating stop. Available Power: " + Math.round(max_available_power) + "W");
                }
            } else if(this.hasReachedHeatingBufferTemp()) {
                if(this.semp_client.requestHeating(0, false)) {
                    console.log("Requested Heating OFF because of reaching heating buffer temp of " + this.getHeatingBufferMax() + "°C");
                }
            }
        }
    }

    isInOverpoweredRegime(min_required_temperature) {
        // The HK temperatures correspond to a lower limit. Use an interpolation midpoint between them 
        // and a more conservative heating buffer temp as target in order to not
        // cycle the heatpump too much.
        let continuous_power_headroom = this.estimateEquilibriumHeatingPower(min_required_temperature) - this.getMinHeatingPower();
        return continuous_power_headroom < 0; // Power requirements below minimum heatpump power
    }

    calculateModulatedHeatingPower(min_available_power, max_available_power, max_heating_power) {
        if(this.stats.isInSummerMode()) { return 0; }
        
        const BASE_TARGET_TEMP_INFLUENCE = 200;
        const MAX_TEMPERATURE_OVERSHOOT = 10;
        let min_power = this.getMinHeatingPower();
        let cur_power = this.semp_client.getHeatingPower(); 
        let max_desired_power = Math.max(max_available_power, this.estimateEfficientWarmupInputPower());
        let temperature_overshoot = this.getHeatingBufferTempOvershoot(); 
        let power_diff = min_available_power - cur_power;
        
        let availability_factor = 1;
        if(temperature_overshoot > 0 && power_diff > 0) { // 10° overshoot makes surplus available power ignored.
            availability_factor = Math.min(1 - (temperature_overshoot / MAX_TEMPERATURE_OVERSHOOT), 1);
        }
        this.modulation_availability_offset = power_diff * availability_factor;

        // Scale down the influence of temperature overshoot with the loss in efficiency while keeping upward temperature correction strong
        let ambient_temperature = this.stats.getAmbientTemp();
        let efficiency_factor = this.estimateHeatPumpEfficiencyFactor(ambient_temperature, this.stats.getHeatingBufferTemp());
        let temperature_factor = temperature_overshoot > 0 ? (BASE_TARGET_TEMP_INFLUENCE / efficiency_factor) : BASE_TARGET_TEMP_INFLUENCE;

        if(!this.stats.areHeatingCirculationPumpsOn() && temperature_overshoot < 0) {
            // Only apply upward temperature correction if the heating circulation pumps are running. Otherwise there is no outflow of energy.
            temperature_factor = 0;
        }
        this.modulation_temp_offset = -1 * temperature_overshoot * Math.abs(temperature_overshoot) * temperature_factor; // Quadratic influence of temp_diff
        let modulated_power = Math.min(cur_power + this.modulation_availability_offset + this.modulation_temp_offset, max_desired_power);
        let recommended_power = Math.min(Math.max(modulated_power, min_power), max_heating_power);

        
        let turn_off_tolerance = this.isOn() ? max_available_power - min_available_power : 0;  // Do not immediately turn off if modulated power dips below zero.
         if(modulated_power + turn_off_tolerance < 0) {
            recommended_power = 0;   // Floor at 0 (= OFF)
        } else if(!this.isOn() && temperature_overshoot >= 0) {
            recommended_power = 0;   // Do not turn on if already above target temperature
        }

        if(this.DEBUG) { console.log("Modulating Heating Power: " + Math.round(recommended_power) + "W - Availability: " + Math.round(this.modulation_availability_offset) + "W (" + Math.round(power_diff) + "W), Temp: " + Math.round(this.modulation_temp_offset) + "W (" + Math.round(temperature_overshoot*10)/10 + "°C)."); }
        return recommended_power;
    }

    resetModulationOffsets() {
        this.modulation_availability_offset = 0;
        this.modulation_temp_offset = 0;
    }

    controlPassiveHeating() {
        if(this.semp_client.getRequestedHeatingPower() > 0) {
            if(this.semp_client.requestHeating(0, true)) {
                console.log("Requested Heating OFF because of canceling previous request after becoming PASSIVE.");
            }
        }
    }

    calculateMaxWarmupHeatingPower() {
        let equilibrium_power = this.estimateEquilibriumHeatingPower(this.getTargetHeatingBufferTemp());
        let buffer_undershoot_compensation = Math.max(-1 * this.getHeatingBufferTempOvershoot() / 5, 0);
        let max_power = this.estimateEfficientWarmupInputPower() + equilibrium_power * buffer_undershoot_compensation;
        return limit(this.getMinHeatingPower(), max_power, this.heating_buffering_input_power_max);
    }
    controlWarmupHeating(min_available_power, max_available_power) {
        let max_heating_power = this.calculateMaxWarmupHeatingPower();
        let modulated_heating_power = this.calculateModulatedHeatingPower(min_available_power, max_available_power, max_heating_power); 
        this.controlHeating(min_available_power, modulated_heating_power, modulated_heating_power);
    }

    controlModulatedHeating(min_available_power, max_available_power) {
        let max_heating_power = this.heating_buffering_input_power_max;
        let modulated_heating_power = this.calculateModulatedHeatingPower(min_available_power, max_available_power, max_heating_power); 
        this.controlHeating(modulated_heating_power, modulated_heating_power, modulated_heating_power);
    }

    controlEfficientHeating(min_available_power, max_available_power) {
        this.setHeatingBufferMax(this.calculateEfficientHeatingBufferMax());
        let recommended_power =  Math.max(this.getMinHeatingPower(), Math.min(min_available_power, this.required_equilibrium_heating_power));
        this.controlHeating(min_available_power, max_available_power, recommended_power);
        this.resetModulationOffsets();
    }

    controlMaxBufferingHeating(min_available_power, max_available_power) {
        let max_recommended_power = max_available_power > this.getMinHeatingPower() ? Math.max(min_available_power, this.getMinHeatingPower()) : 0;
        let recommended_power = Math.min(max_recommended_power, this.heating_buffering_input_power_max);
        this.controlHeating(min_available_power, max_available_power, recommended_power);  
        this.resetModulationOffsets();
    }

    reportStatus() {
        console.log(this.semp_client.getHeatingPlanString());
    }

    updateState() {
        this.semp_client.updateState();
        this.stats.updateState();
        this.warmwater_expected_power = this.estimateExpectedWarmWaterPowerAtTemp(this.stats.getWarmWaterTemp());
        this.heating_expected_power = this.estimateExpectedHeatingPower(this.stats.getHeatingBufferTemp());

        if(this.stats.isInSummerMode()) {
            this.warmwater_output_power = 1000 * getStateIfExisting(this.ww_output_power_kw_summer_obj, this.warmwater_output_power);
        } else {
            this.warmwater_output_power = 1000 * getStateIfExisting(this.ww_output_power_kw_winter_obj, this.warmwater_output_power);
        }
           
        this.required_warmwater_runtime = this.estimateWarmWaterRunMinsRequired(this.getWarmWaterTarget()); 
        this.required_heating_runtime = this.estimateHeatingRunMinsRequired(this.getHeatingBufferMax()); 
        this.required_equilibrium_heating_power = this.estimateEquilibriumHeatingPower(this.getTargetHeatingBufferTemp());

        accumulateDailyEnergyStat(this.DAY_HEATING_ENERGY_OBJ, this.semp_client.getHeatingPower());
        accumulateDailyEnergyStat(this.DAY_WARMWATER_ENERGY_OBJ, this.semp_client.getWarmWaterPower());

        let efficiency_factor = this.estimateCurrentHeatPumpEfficiencyFactor();
        setState(this.EFFICIENCY_FACTOR, efficiency_factor, true);
        setState(this.ESTIMATED_WARMWATER_POWER, this.warmwater_expected_power, true);
        setState(this.EMI_MODE, this.getEmiModeCode(), true);

        if(!this.stats.isInSummerMode()) {
            setState(this.MODULATION_RECOMMENDED, this.modulation_recommended, true);
            setState(this.MODULATION_OFFSET_AVAILABILITY, this.modulation_availability_offset, true);
            setState(this.MODULATION_OFFSET_TEMPERATURE, this.modulation_temp_offset, true);
            setState(this.EQUILIBRIUM_HEATING_POWER, this.required_equilibrium_heating_power, true);
            setState(this.HEATING_BUFFER_TEMP, this.stats.getHeatingBufferTemp(), true);
            setState(this.HEATING_BUFFER_MAX_TEMP, this.heating_buffer_max, true);
            setState(this.HEATING_BUFFER_TEMP_OVER, this.getHeatingBufferTempOvershoot(), true);
        }
        this.semp_client.writeState();
    }
}