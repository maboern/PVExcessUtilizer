/* -- do not edit following lines - START --
{
  "expert": true,
  "debug": false,
  "verbose": false
}
-- do not edit previous lines - END --*/

const SPECIFIC_HEAT_CAPACITY_WATER_KWH = 4.186 / 3600; // 4.186 kJ/kg·°C; 3600 kJ/kWh

class HeatPump {
      constructor(root_obj, boiler) {
        this.root_obj = root_obj + ".heatpump";
        this.semp_client = new HeatPumpSempClient(this.root_obj);
        this.boiler = boiler;
        this.DEBUG = false;

        this.ambient_temperature_sensor_obj = 'stiebel-isg.0.info.ANLAGE.HEIZUNG.AUSSENTEMPERATUR';
        this.heating_buffer_temp_obj = 'stiebel-isg.0.info.ANLAGE.HEIZUNG.PUFFERISTTEMPERATUR';
        this.target_hk2_temp_obj = 'stiebel-isg.0.info.ANLAGE.HEIZUNG.SOLLTEMPERATUR_HK_2';
        this.target_hk3_temp_obj = 'stiebel-isg.0.info.ANLAGE.HEIZUNG.SOLLTEMPERATUR_HK_3';
        this.summer_mode_obj = 'stiebel-isg.0.info.STATUSANLAGE.BETRIEBSSTATUS.SOMMERBETRIEB';
        this.hk2_pump_obj = 'stiebel-isg.0.info.STATUSANLAGE.STATUS_ANLAGE.HEIZKREISPUMPE_2';
        this.hk3_pump_obj = 'stiebel-isg.0.info.STATUSANLAGE.STATUS_ANLAGE.HEIZKREISPUMPE_3';
        this.ww_output_power_kw_summer_obj = 'stiebel-isg.0.settings.WARMWASSER.WW LEISTUNG WP.val1126';
        this.ww_output_power_kw_winter_obj = 'stiebel-isg.0.settings.WARMWASSER.WW LEISTUNG WP.val1127';
        this.ww_eco_temp_obj = 'stiebel-isg.0.settings.WARMWASSER.WARMWASSERTEMPERATUREN.val11019';
        this.ww_hysteresis_obj = 'stiebel-isg.0.settings.WARMWASSER.GRUNDEINSTELLUNG.val120';
        this.hk2_room_temp_obj = 'stiebel-isg.0.info.ANLAGE.RAUMTEMPERATUR.ISTTEMPERATUR_2';
        this.hk3_room_temp_obj = 'stiebel-isg.0.info.ANLAGE.RAUMTEMPERATUR.ISTTEMPERATUR_3';
        this.hk2_room_temp_target_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 2.val10980';     
        this.hk3_room_temp_target_obj = 'stiebel-isg.0.settings.HEIZEN.HEIZKREIS 3.val10986';
        this.compressor_starts_obj = 'stiebel-isg.0.info.WAERMEPUMPE.STARTS.VERDICHTER';
        this.compressor_starts_defrost_obj = 'stiebel-isg.0.info.WAERMEPUMPE.LAUFZEIT.STARTS_ABTAUEN';

        this.required_boiler_runtime = 0;
        this.required_warmwater_runtime = 0;
        this.required_heating_runtime = 0;
        this.required_equilibrium_heating_power = 0;

        this.min_heatpump_runtime_mins = 15; // Do not start the heatpump if it is expected to run less than that time.
        this.min_heating_pause_secs = 10*60; // Grace period between heating runs
        this.heating_buffer_volume = 400; // 400 l
        this.heating_buffer_temperature_corr = 4; // The HK mixers are less than half-open if the heating buffer sensor reports hitting the required temperature. 
        this.warmwater_output_power = 7000; // The heatpump works in a constant output (heat) power regime with variable electric power input
        this.heating_buffering_input_power_target = 2000; // The expected "norm" power when heating buffering.
        this.heating_buffering_input_power_max = 3500; // The "maximum" power when heating buffering
        this.heating_expected_power = 1500;
        this.warmwater_expected_power = 2500; 

         
        this.hk2_room_temp_comfort = 21;
        this.hk2_room_temp_overheat = 21.6;
        this.hk2_room_temp_eco = 20.6;
        this.hk3_room_temp_comfort = 22;
        this.hk3_room_temp_overheat = 22.8;
        this.hk3_room_temp_eco = 21.6;

        this.warmwater_target = EFFICIENT_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp();
        this.heating_buffer_max = EFFICIENT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp();
        this.hk2_pump_on = getStateIfExisting(this.hk2_pump_obj, false);
        this.hk3_pump_on = getStateIfExisting(this.hk3_pump_obj, false);

        this.modulation_recommended = 0;
        this.modulation_temp_offset = 0;
        this.modulation_availability_offset = 0;

        this.compressor_starts = 0;
        this.compressor_starts_defrost = 0;
        
        this.HK2_PUMP_OBJ = this.root_obj + ".hk2_pump";
        createState(this.HK2_PUMP_OBJ, false, {read: true, write: false, name: "Pump HK2", type: "boolean", def: false});
        this.HK3_PUMP_OBJ = this.root_obj + ".hk3_pump";
        createState(this.HK3_PUMP_OBJ, false, {read: true, write: false, name: "Pump HK3", type: "boolean", def: false});
        this.EFFICIENCY_FACTOR = this.root_obj + ".efficiency";
        createState(this.EFFICIENCY_FACTOR, 1, {read: true, write: false, name: "Heatpump Efficency Factor", type: "number", def: 1});
        this.COMPRESSOR_STARTS = this.root_obj + ".compressor_starts";
        createState(this.COMPRESSOR_STARTS, 0, {read: true, write: false, name: "Heatpump Compressor Starts", type: "number", def: 0});
        this.COMPRESSOR_STARTS_DEFROST = this.root_obj + ".compressor_starts_defrost";
        createState(this.COMPRESSOR_STARTS_DEFROST, 0, {read: true, write: false, name: "Heatpump Compressor Starts (Defrosting)", type: "number", def: 0});
        this.ESTIMATED_WARMWATER_POWER = this.root_obj + ".estimated_warmwater_power";
        createState(this.ESTIMATED_WARMWATER_POWER, 0, {read: true, write: false, name: "Estimated WarmWater Power", type: "number", unit: "W", def: 0});
        this.EMI_MODE = this.root_obj + ".emi_mode";
        createState(this.EMI_MODE, "UNKNOWN", {read: true, write: false, name: "EMI Mode", type: "string", def: "UNKNOWN"});
        

        this.HEATING_BUFFER_TEMP = this.root_obj + ".heating_buffer_temp";
        createState(this.HEATING_BUFFER_TEMP, 40, {read: true, write: false, name: "Heating Buffer Temperature (corrected)", type: "number", unit: "°C", def: 45});
        this.HEATING_BUFFER_MAX_TEMP = this.root_obj + ".heating_buffer_max_temp";
        createState(this.HEATING_BUFFER_MAX_TEMP, 45, {read: true, write: false, name: "Max Heating Buffer Temperature", type: "number", unit: "°C", def: 45});
        this.HEATING_BUFFER_TEMP_OVER = this.root_obj + ".heating_buffer_temp_overshoot";
        createState(this.HEATING_BUFFER_TEMP_OVER, 0, {read: true, write: false, name: "Heating Buffer Temperature Overshoot", type: "number", unit: "°C", def: 0});
        this.EQUILIBRIUM_HEATING_POWER = this.root_obj + ".equilibrium_heating_power";
        createState(this.EQUILIBRIUM_HEATING_POWER, 0, {read: true, write: false, name: "Required Equilibrium Heating Power", type: "number", unit: "W", def: 0});
        this.MODULATION_RECOMMENDED = this.root_obj + ".modulation_recommended";
        createState(this.MODULATION_RECOMMENDED, 0, {read: true, write: false, name: "Recommended Power Modulation", type: "number", unit: "W", def: 0});
        this.MODULATION_OFFSET_AVAILABILITY = this.root_obj + ".modulation_availability_offset";
        createState(this.MODULATION_OFFSET_AVAILABILITY, 0, {read: true, write: false, name: "Recommended Power Offset Availability", type: "number", unit: "W", def: 0});
        this.MODULATION_OFFSET_TEMPERATURE = this.root_obj + ".modulation_temperature_offset";
        createState(this.MODULATION_OFFSET_TEMPERATURE, 0, {read: true, write: false, name: "Recommended Power Offset Temperature", type: "number", unit: "W", def: 0});

        this.DAY_WARMWATER_ENERGY_OBJ = this.root_obj + ".day_warmwater_energy";
        createState(this.DAY_WARMWATER_ENERGY_OBJ, 0, {read: true, write: false, name: "WarmWater Energy Day", type: "number", unit: "Wh", def: 0});
        this.DAY_HEATING_ENERGY_OBJ = this.root_obj + ".day_heating_energy";
        createState(this.DAY_HEATING_ENERGY_OBJ, 0, {read: true, write: false, name: "Heating Energy Day", type: "number", unit: "Wh", def: 0});

        this.updateState();
    }  
    
    getWarmWaterEcoTemp() { return getStateIfExisting(this.ww_eco_temp_obj, 42.5);}
    getWarmWaterHysteresis() { return getStateIfExisting(this.ww_hysteresis_obj, 6);}
    getWarmWaterTarget() { return this.warmwater_target; }
    setWarmWaterTarget(temp, reason) {
        if(temp != this.warmwater_target) {
            this.warmwater_target = temp;
            let reason_suffix = '.';
            if(reason) { reason_suffix = " because of " + reason + "."; }
            console.log("Changing target WarmWater temperature to " + temp + "°C" + reason_suffix);
        }
        this.updateState();
    }
    getEmiMode() {
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_OK', null)) { return "EMI_OK";}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_HIGH', null)) { return "EMI_ACTIVE_HIGH";}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_COMFORT', null)) { return "EMI_ACTIVE_COMFORT";}
        if(getStateIfExisting('stiebel-isg.0.info.ANLAGE.ENERGIEMANAGEMENT.EMI_ACTIVE_ECO', null)) { return "EMI_ACTIVE_ECO";}
        return "UNKNOWN";
    }

    calculateEfficientHeatingBufferMax() {
        const HEATING_BUFFER_HYSTERESIS = 5; // Go max 5°C above target temperature
        const LOWEST_HEATING_BUFFER_MAX = 32; // But at least 32°C
        return Math.max(this.getTargetHeatingBufferTemp() + HEATING_BUFFER_HYSTERESIS, LOWEST_HEATING_BUFFER_MAX);
    }
    getHeatingBufferMax() { return this.heating_buffer_max; }
    setHeatingBufferMax(temp, reason) {
        if(temp != this.heating_buffer_max) {
            this.heating_buffer_max = temp;
            let reason_suffix = '.';
            if(reason) { reason_suffix = " because of " + reason + "."; }
            if(this.DEBUG) { console.log("Changing Max Heating Buffer temperature to " + temp + "°C" + reason_suffix); }
        }
        this.updateState();
    }
    getRequestedHeatingPower() { return this.semp_client.getRequestedHeatingPower(); }
    isInSummerMode() { return getStateIfExisting(this.summer_mode_obj, false);  }
    areHeatingCirculationPumpsOn() { return this.hk2_pump_on || this.hk3_pump_on; }
    getHeatingBufferTemp() { 
        return getStateIfExistingWithMaxAge(this.heating_buffer_temp_obj, 3*60*60, EFFICIENT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp()) +  this.heating_buffer_temperature_corr; 
    }
    getTargetHeatingBufferTemp() {
        let target_hk2_temp = getStateIfExistingWithMaxAge(this.target_hk2_temp_obj, 3*60*60, EFFICIENT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp());
        let target_hk3_temp = getStateIfExistingWithMaxAge(this.target_hk3_temp_obj, 3*60*60, EFFICIENT_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp());
        return Math.max(target_hk2_temp, target_hk3_temp);
    }
    getHeatingBufferTempOvershoot() { return this.getHeatingBufferTemp() - this.getTargetHeatingBufferTemp();   }
    isHeatingBufferTempAtEfficientMax() { return this.getHeatingBufferTemp() - this.calculateEfficientHeatingBufferMax() > 0;}
    
    startRoomOverheating() {
        if(!this.isRoomOverheating()) {
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_overheat, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_overheat, false);
            console.log("Started Room Overheating.")
        }
    }
    stopRoomOverheating() {
        if(this.isRoomOverheating()) { 
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_comfort, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort, false);
            console.log("Stopped Room Overheating.")
        }
    }
    isRoomOverheating() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort);
        return hk3_room_temp_target > this.hk3_room_temp_comfort;
    }

    areRoomsOverheated() {
        const MIN_ROOM_OVERHEATING_THRESHOLD = 0.2;
        let hk2_room_temp = getStateIfExisting(this.hk2_room_temp_obj, this.hk2_room_temp_comfort);
        let hk3_room_temp = getStateIfExisting(this.hk3_room_temp_obj, this.hk3_room_temp_comfort);
        if(hk2_room_temp >= this.hk2_room_temp_comfort + MIN_ROOM_OVERHEATING_THRESHOLD && 
            hk3_room_temp >= this.hk3_room_temp_comfort + MIN_ROOM_OVERHEATING_THRESHOLD) {
            return true;
        } else {
            return false;
        }
    }

    startRoomUnderheating() {
        if(!this.isRoomUnderheating()) {
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_eco, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_eco, false);
            console.log("Started Room Underheating.")
        }
    }
    stopRoomUnderheating() {
        if(this.isRoomUnderheating()) { 
            setState(this.hk2_room_temp_target_obj, this.hk2_room_temp_comfort, false);
            setState(this.hk3_room_temp_target_obj, this.hk3_room_temp_comfort, false);
            console.log("Stopped Room Underheating.")
        }
    }
    isRoomUnderheating() {
        let hk3_room_temp_target = getStateIfExisting(this.hk3_room_temp_target_obj, this.hk3_room_temp_eco);
        return hk3_room_temp_target < this.hk3_room_temp_comfort;
    }

    estimateCurrentHeatPumpEfficiencyFactor() {
        let ambient_temperature = getStateIfExistingWithMaxAge(this.ambient_temperature_sensor_obj, 12*60*60, 10);
        if(this.isHeatingOn()) {
            return this.estimateHeatPumpEfficiencyFactor(ambient_temperature, this.getHeatingBufferTemp());
        } else if(this.isWarmWaterOn()) {
            return this.estimateHeatPumpEfficiencyFactor(ambient_temperature, this.getWarmWaterTemp());
        } else {
            return 0;
        }
    }

    estimateHeatPumpEfficiencyFactor(ambient_temp, output_temp) {
        // Ambient:        W35           W55
        // 20°C             6.21        3.56
        // 10°C             5.48
        //  7°C             4.72        3.19
        //  2°C             4.00        2.91
        // -7°C             3.00        2.34
        //-15°C             2.67        2.07
        // Approximate with pessimistic values (datasheet does not account for fan/pump/spread)
        const HEATPUMP_SPREAD_DEGREES = 4;

        let temp_delta = output_temp + HEATPUMP_SPREAD_DEGREES - ambient_temp;
        if(temp_delta < 15) { return 6; } else
        if(temp_delta < 25) { return 5 + (25 - temp_delta)/10; } else
        if(temp_delta < 35) { return 4 + (35 - temp_delta)/10; } else 
        if(temp_delta < 45) { return 3 + (45 - temp_delta)/10; } else
        if(temp_delta < 55) { return 2 + (55 - temp_delta)/10; }
        else { return 1; }
    }

    estimateEquilibriumHeatingOutputPower() {
        // Auslegung Heizug: 7.8kW @ -10°C - linear interpolation to 0kW @ +20°C
        let ambient_temperature = getStateIfExistingWithMaxAge(this.ambient_temperature_sensor_obj, 12*60*60, 10);
        let output_power = 7800 * (30 - (ambient_temperature + 10)) / 30;
        return Math.max(output_power, 0);
    }

    estimateEquilibriumHeatingPower(target_temperature) {
        if(this.isInSummerMode()) { return 0; }
        let ambient_temperature = getStateIfExistingWithMaxAge(this.ambient_temperature_sensor_obj, 12*60*60, 10);
        let output_power = this.estimateEquilibriumHeatingOutputPower();
        let input_power = output_power / this.estimateHeatPumpEfficiencyFactor(ambient_temperature, target_temperature);
        return input_power;
    }

    estimateExpectedHeatingPower(target_temperature) {
        return Math.max(this.estimateEquilibriumHeatingPower(target_temperature), this.getMinHeatingPower());
    }

    estimateExpectedHeatingBufferingOutputPower(target_temperature) {
        // This is a pessimistic estimate, because the heatpump is calculated at the target temperature efficiency factor the whole time
        // while in reality it starts at the efficiency factor of the current temperature.
        let ambient_temperature = getStateIfExistingWithMaxAge(this.ambient_temperature_sensor_obj, 12*60*60, 10);
        return this.heating_buffering_input_power_target * this.estimateHeatPumpEfficiencyFactor(ambient_temperature, target_temperature);
    }

    estimateHeatingRunMinsRequired(target_temperature) {
        var energy_kwh = this.estimateHeatingEnergyRequired(target_temperature);
        var time_hours = (energy_kwh * 1000) / (this.estimateExpectedHeatingBufferingOutputPower(target_temperature));
        if(this.areHeatingCirculationPumpsOn()) {
            let equilibrium_output_power = this.estimateEquilibriumHeatingOutputPower();
            let equilibrium_energy = equilibrium_output_power * time_hours / 1000;
            time_hours *= 1 + (equilibrium_energy / energy_kwh)
        }
        return Math.round(time_hours * 60);
    }
    
    estimateHeatingEnergyRequired(target_temperature) {
        if(this.isInSummerMode()) { return 0; }
        
        let buffer_temperature = this.getHeatingBufferTemp();
        var temperature_diff = target_temperature - buffer_temperature;
        if(temperature_diff < 0) {
            temperature_diff = 0;
        }
        var boiler_kwh_per_degree = this.heating_buffer_volume * SPECIFIC_HEAT_CAPACITY_WATER_KWH;
        var required_energy_kwh = boiler_kwh_per_degree * temperature_diff;
        if(this.DEBUG) { console.log("Heating Buffer Target: " + target_temperature + "°C, Current: " + buffer_temperature + " => Energy: " + required_energy_kwh + "kWh");}
        return required_energy_kwh;
    }

    estimateExpectedWarmWaterPowerAtTemp(warmwater_temp) {
        let ambient_temperature = getStateIfExistingWithMaxAge(this.ambient_temperature_sensor_obj, 12*60*60, 10);
        let temperature_delta = warmwater_temp - ambient_temperature;

        // Measured power: 1.5kW@35° 1.9kW@44°, 2.7kW@48°, 5kW@55° (7kW output power, 10°C outside)
        // => 1500W @ 25° delta, 1900W @ 34° delta, 2700W @ 38° delta, 5000W @ 45° delta
        // Linearize between these points

        if(temperature_delta < 25) {
            return 1500;
        } else if(temperature_delta < 34) {
            return 1500 + (temperature_delta - 25) * 44;
        } else if(temperature_delta < 38) {
            return 1900 + (temperature_delta - 34) * 200;
        } else {
            return 2700 + (temperature_delta - 38) * 329;
        }
    }

    estimateWarmWaterRunMinsRequired(target_temperature) {
        var energy_kwh = this.estimateWarmWaterEnergyRequired(target_temperature);
        var time_hours = (energy_kwh * 1000) / (this.warmwater_output_power); 
        return Math.round(time_hours * 60);
    }

    estimateBoilerRunMinsRequired(target_temperature) {
        var energy_kwh = this.estimateWarmWaterEnergyRequired(target_temperature);
        var time_hours = (energy_kwh * 1000) / this.boiler.getExpectedPower();
        return Math.round(time_hours * 60);
    }

    estimateWarmWaterEnergyRequired(target_temperature) {
        var temperature_diff = target_temperature - this.getWarmWaterTemp();
        if(temperature_diff < 0) {
            temperature_diff = 0;
        }
        var kwh_per_degree = this.boiler.getVolume() * SPECIFIC_HEAT_CAPACITY_WATER_KWH;
        var required_energy_kwh = kwh_per_degree * temperature_diff;
        if(this.DEBUG) { console.log("Warm Water Target: " + target_temperature + "°C, Current: " + this.getWarmWaterTemp() + " => Energy: " + required_energy_kwh + "kWh");}
        return required_energy_kwh;
    }

    isWarmWaterAllowedToStart() {  return (this.required_warmwater_runtime >= this.min_heatpump_runtime_mins); }
    isWarmWaterAllowedToStop() { 
        let min_runtime_elapsed = !isNowInTimePeriod(this.semp_client.getWarmWaterStartTimeStamp(), this.min_heatpump_runtime_mins*60*1000);
        return this.semp_client.isWarmWaterControllable() && min_runtime_elapsed; }
    isWarmWaterOn() { return this.semp_client.isWarmWaterOn(); }

    hasHeatingMinPauseElapsed() { return (Date.now() - this.semp_client.getHeatingStopTimeStamp() > this.min_heating_pause_secs);}
    isHeatingAllowedToStart() { return (this.required_heating_runtime >= this.min_heatpump_runtime_mins) && this.hasHeatingMinPauseElapsed() && !this.semp_client.isWarmWaterStartingUp();}
    isHeatingAllowedToStop() { return this.semp_client.isHeatingControllable(); }
    isHeatingOn() { return this.semp_client.isHeatingOn(); }
    isHeatingStartingUp() { return this.semp_client.isHeatingStartingUp();}

    isAllowedToStart() { return (this.isWarmWaterAllowedToStart() || this.isHeatingAllowedToStart());  }
    isOn() { return this.isWarmWaterOn() || this.isHeatingOn(); }
    getRequiredWarmWaterRunTimeToMaxBuffer() { return this.estimateWarmWaterRunMinsRequired(MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp());}
    getRequiredBoilerRunTimeToMaxBuffer() { return this.estimateBoilerRunMinsRequired(MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp()); }
    getRequiredHeatingRunTimeToMaxBuffer() { return this.estimateHeatingRunMinsRequired(MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getHeatingBufferTemp()); }
    getExpectedWarmWaterPower() { return this.warmwater_expected_power; }
    getExpectedHeatingPower() { return this.heating_expected_power; }
    getMinHeatingPower() { return this.semp_client.getHeatingMinPower(); }
    getMaxHeatingPower() { return this.semp_client.getHeatingMaxPower(); }
    getExpectedBoilerPower() { return this.boiler.getExpectedPower(); }
    getCurrentPower() { return this.semp_client.getHeatingPower() + this.semp_client.getWarmWaterPower(); }
    getCurrentWarmWaterPower() { return this.semp_client.getWarmWaterPower(); }
    getCurrentHeatingPower() { return this.semp_client.getHeatingPower(); }
    getWarmWaterTemp() {return this.boiler.getTemperature() + this.calculateWarmWaterPertubationCorrection(); }
    hasReachedWarmWaterTemp() { return this.getWarmWaterTemp() >= this.getWarmWaterTarget(); }
    hasReachedMaxBufferWarmWaterTemp() { return this.getWarmWaterTemp() >= MAX_BUFFER_HEATPUMP_EMI_SETTINGS.getWarmWaterTemp(); }
    hasReachedHeatingBufferTemp() { return this.getHeatingBufferTemp() >= this.getHeatingBufferMax(); }

    calculateWarmWaterPertubationCorrection() {
        const PERTUBATION_TIME_SECS = 7*60; // How long it takes for the WW to be fully pertubed.
        const PERTUBATION_SETTLING_TIME_SECS = 10*60; // How long it takes for the WW to settle again.
        const PERTUBATION_CORRECTION = 2.0; // Max Correction in °C for full pertubation.
        let ww_start_ts = this.semp_client.getWarmWaterStartTimeStamp();
        let ww_stop_ts = this.semp_client.getWarmWaterStopTimeStamp();

        if(isNowInTimePeriod(ww_stop_ts, PERTUBATION_SETTLING_TIME_SECS * 1000)) {
            let settling_time_fraction = (Date.now() - ww_stop_ts)/(PERTUBATION_SETTLING_TIME_SECS * 1000);
            return (1 - settling_time_fraction) * PERTUBATION_CORRECTION;
        } else if(isNowInTimePeriod(ww_start_ts, PERTUBATION_TIME_SECS * 1000)) {
            let pertubation_time_fraction = (Date.now() - this.semp_client.getWarmWaterStartTimeStamp())/(PERTUBATION_TIME_SECS * 1000);
            return pertubation_time_fraction * PERTUBATION_CORRECTION;
        } else if(this.isWarmWaterOn()) {
            return PERTUBATION_CORRECTION; // Pertubation has reached full extend - full pertubation.
        } else {
            return 0; // Default case while WW is off - no pertubation.
        }
    }

    controlWarmWaterPassive(max_available_power) { this.controlWarmWater(0, max_available_power); }
    controlWarmWater(min_available_power, max_available_power) {
        let expected_power_consumption = this.isWarmWaterOn() ? this.semp_client.getWarmWaterPower() : this.getExpectedWarmWaterPower();
        
        if(this.DEBUG) { console.log("Expected WW Power: " + expected_power_consumption + "W, Min AV: " + min_available_power + "W, Max AV: " + max_available_power + "W"); }
        if(this.isWarmWaterAllowedToStart() || (this.isWarmWaterOn() && this.semp_client.isWarmWaterControllable())) {
            if(min_available_power >= expected_power_consumption && !this.hasReachedWarmWaterTemp()) {
                if(this.semp_client.requestWarmWater(true, false)) {
                    console.log("Requested WarmWater ON with min power: " + Math.round(min_available_power) + "W / " + expected_power_consumption + "W");
                }
            } 
        }
        this.stopWarmWaterIfNecessary(expected_power_consumption, max_available_power)
    }

    stopWarmWaterIfNecessary(expected_power_consumption, available_power) {
       if(this.isWarmWaterAllowedToStop()) {
            if(available_power < expected_power_consumption) {
                if(this.semp_client.requestWarmWater(false, false)) {
                    console.log("Requested WarmWater OFF because of low available power: " + Math.round(available_power) + "W / " + Math.round(expected_power_consumption) + "W");
                }
            } else if(this.hasReachedWarmWaterTemp()) {
                if(this.semp_client.requestWarmWater(false, false)) {
                    console.log("Requested WarmWater OFF because of reaching warmwater temp of " + this.getWarmWaterTarget() + "°C");
                }
            }
        }
    }

    controlHeating(min_available_power, max_available_power, recommended_power) {
        this.modulation_recommended = recommended_power;
        let min_heating_power = this.getMinHeatingPower(); 
        if(this.isHeatingAllowedToStart() || (this.isHeatingOn() && this.semp_client.isHeatingControllable())) {
            if(min_available_power >= min_heating_power && !this.hasReachedHeatingBufferTemp() && recommended_power > 0) {
                if(this.semp_client.requestHeating(recommended_power, false)) {
                    console.log("Requested Heating ON with recommended power: " + Math.round(recommended_power) + "W / " + Math.round(min_heating_power) + "W");
                }
            } 
        }
        if(this.isHeatingAllowedToStop()) { 
            if(max_available_power < min_heating_power  && !this.isWarmWaterOn()) { // Never cancel Heating request if Warmwater is on
                if(this.semp_client.requestHeating(0, false)) {
                    console.log("Requested Heating OFF because of low available power: " + Math.round(max_available_power) + "W / " + Math.round(min_heating_power) + "W");
                }
            } else if(recommended_power == 0) {
                if(this.semp_client.requestHeating(0, false)) {
                    console.log("Requested Heating OFF because of recommended power indicating stop. Available Power: " + Math.round(max_available_power) + "W");
                }
            } else if(this.hasReachedHeatingBufferTemp()) {
                if(this.semp_client.requestHeating(0, false)) {
                    console.log("Requested Heating OFF because of reaching heating buffer temp of " + this.getHeatingBufferMax() + "°C");
                }
            }
        }
    }

    isInOverpoweredRegime(min_required_temperature) {
        // The HK temperatures correspond to a lower limit. Use an interpolation midpoint between them 
        // and a more conservative heating buffer temp as target in order to not
        // cycle the heatpump too much.
        let continuous_power_headroom = this.estimateEquilibriumHeatingPower(min_required_temperature) - this.getMinHeatingPower();
        return continuous_power_headroom < 0;// Power requirements below minimum heatpump power
    }

    calculateModulatedHeatingPower(min_available_power, max_available_power) {
        if(this.isInSummerMode()) { return 0; }
        
        const BASE_TARGET_TEMP_INFLUENCE = 200;
        const MAX_TEMPERATURE_OVERSHOOT = 10;
        let min_power = this.getMinHeatingPower();
        let cur_power = this.semp_client.getHeatingPower(); 
        let temperature_overshoot = this.getHeatingBufferTempOvershoot();

        let desired_power = min_available_power; 
        let power_diff = desired_power - cur_power;
        
        let availability_factor = 1;
        if(temperature_overshoot > 0 && power_diff > 0) { // 10° overshoot makes surplus available power ignored.
            availability_factor = Math.min(1 - (temperature_overshoot / MAX_TEMPERATURE_OVERSHOOT), 1);
        }
        this.modulation_availability_offset = power_diff * availability_factor;

        // Scale down the influence of temperature overshoot with the loss in efficiency while keeping upward temperature correction strong
        let ambient_temperature = getStateIfExistingWithMaxAge(this.ambient_temperature_sensor_obj, 12*60*60, 10);
        let efficiency_factor = this.estimateHeatPumpEfficiencyFactor(ambient_temperature, this.getHeatingBufferTemp());
        let temperature_factor = temperature_overshoot > 0 ? (BASE_TARGET_TEMP_INFLUENCE / efficiency_factor) : BASE_TARGET_TEMP_INFLUENCE;

        if(!this.areHeatingCirculationPumpsOn() && temperature_overshoot < 0) {
            // Only apply upward temperature correction if the heating circulation pumps are running. Otherwise there is no outflow of energy.
            temperature_factor = 0;
        }
        this.modulation_temp_offset = -1 * temperature_overshoot * Math.abs(temperature_overshoot) * temperature_factor; // Quadratic influence of temp_diff
        let modulated_power = Math.min(cur_power + this.modulation_availability_offset + this.modulation_temp_offset, desired_power);
        let recommended_power = Math.max(modulated_power, min_power);

        
        let turn_off_tolerance = this.isOn() ? max_available_power - min_available_power : 0;  // Do not immediately turn off if modulated power dips below zero.
        if(this.isInOverpoweredRegime(this.getTargetHeatingBufferTemp()) && 
                this.isHeatingOn() && this.modulation_temp_offset + cur_power > 0 && temperature_overshoot < MAX_TEMPERATURE_OVERSHOOT) {
            // Always recommend minimum power if the heating energy requirements of the house are below
            // the minimum power requirements.
            recommended_power = min_power;
        } else if(modulated_power + turn_off_tolerance < 0) {
            recommended_power = 0;   // Floor at 0 (= OFF)
        } else if(!this.isOn() && temperature_overshoot >= 0) {
            recommended_power = 0;   // Do not turn on if already above target temperature
        }

        if(this.DEBUG) { console.log("Modulating Heating Power: " + Math.round(recommended_power) + "W - Availability: " + Math.round(this.modulation_availability_offset) + "W (" + Math.round(power_diff) + "W), Temp: " + Math.round(this.modulation_temp_offset) + "W (" + Math.round(temperature_overshoot*10)/10 + "°C)."); }
        return recommended_power;
    }

    resetModulationOffsets() {
        this.modulation_availability_offset = 0;
        this.modulation_temp_offset = 0;
    }

    controlPassiveHeating() {
        if(this.semp_client.getRequestedHeatingPower() > 0) {
            if(this.semp_client.requestHeating(0, true)) {
                console.log("Requested Heating OFF because of canceling previous request after becoming PASSIVE.");
            }
        }
    }

    controlModulatedHeating(min_available_power, max_available_power) {
        let modulated_heating_power = this.calculateModulatedHeatingPower(min_available_power, max_available_power); 
        this.controlHeating(min_available_power, modulated_heating_power, modulated_heating_power);
    }

    controlEfficientHeating(min_available_power, max_available_power) {
        this.setHeatingBufferMax(this.calculateEfficientHeatingBufferMax());
        let recommended_power =  Math.max(this.getMinHeatingPower(), Math.min(min_available_power, this.required_equilibrium_heating_power));
        this.controlHeating(min_available_power, max_available_power, recommended_power);
        this.resetModulationOffsets();
    }

    controlMaxBufferingHeating(min_available_power, max_available_power) {
        let max_recommended_power = max_available_power > this.getMinHeatingPower() ? Math.max(min_available_power, this.getMinHeatingPower()) : 0;
        let recommended_power = Math.min(max_recommended_power, this.heating_buffering_input_power_max);
        this.controlHeating(min_available_power, max_available_power, recommended_power);  
        this.resetModulationOffsets();
    }

    monitorCompressorStarts() {
        let prev_compressor_starts = this.compressor_starts;
        this.compressor_starts = getStateIfExisting(this.compressor_starts_obj, this.compressor_starts);
        if(prev_compressor_starts != 0 && this.compressor_starts > prev_compressor_starts) {
            updateDailyStat(this.COMPRESSOR_STARTS, 1);
            console.log("HP: Compressor START");
        }

        let prev_compressor_starts_defrost = this.compressor_starts_defrost;
        this.compressor_starts_defrost = getStateIfExisting(this.compressor_starts_defrost_obj, this.compressor_starts_defrost);
        if(prev_compressor_starts_defrost != 0 && this.compressor_starts_defrost > prev_compressor_starts_defrost) {
            updateDailyStat(this.COMPRESSOR_STARTS_DEFROST, 1);
            console.log("HP: Compressor DEFROST START");
        }
    }

    updateState() {
        this.semp_client.updateState();
        this.warmwater_expected_power = this.estimateExpectedWarmWaterPowerAtTemp(this.getWarmWaterTemp());
        this.heating_expected_power = this.estimateExpectedHeatingPower(this.getHeatingBufferTemp());
        this.monitorCompressorStarts();

        if(this.isInSummerMode()) {
            this.warmwater_output_power = 1000 * getStateIfExisting(this.ww_output_power_kw_summer_obj, this.warmwater_output_power);
        } else {
            this.warmwater_output_power = 1000 * getStateIfExisting(this.ww_output_power_kw_winter_obj, this.warmwater_output_power);
        }
           
        this.required_warmwater_runtime = this.estimateWarmWaterRunMinsRequired(this.getWarmWaterTarget()); 
        this.required_heating_runtime = this.estimateHeatingRunMinsRequired(this.getHeatingBufferMax()); 
        this.required_equilibrium_heating_power = this.estimateEquilibriumHeatingPower(this.getTargetHeatingBufferTemp());

        accumulateDailyEnergyStat(this.DAY_HEATING_ENERGY_OBJ, this.semp_client.getHeatingPower());
        accumulateDailyEnergyStat(this.DAY_WARMWATER_ENERGY_OBJ, this.semp_client.getWarmWaterPower());

        let efficiency_factor = this.estimateCurrentHeatPumpEfficiencyFactor();
        setState(this.EFFICIENCY_FACTOR, efficiency_factor, true);
        setState(this.ESTIMATED_WARMWATER_POWER, this.warmwater_expected_power, true);
        setState(this.EMI_MODE, this.getEmiMode(), true);

        if(!this.isInSummerMode()) {
            this.hk2_pump_on = getStateIfExisting(this.hk2_pump_obj, false);
            setState(this.HK2_PUMP_OBJ, this.hk2_pump_on, true);
            this.hk3_pump_on = getStateIfExisting(this.hk3_pump_obj, false);
            setState(this.HK3_PUMP_OBJ, this.hk3_pump_on, true);

            setState(this.MODULATION_RECOMMENDED, this.modulation_recommended, true);
            setState(this.MODULATION_OFFSET_AVAILABILITY, this.modulation_availability_offset, true);
            setState(this.MODULATION_OFFSET_TEMPERATURE, this.modulation_temp_offset, true);
            setState(this.EQUILIBRIUM_HEATING_POWER, this.required_equilibrium_heating_power, true);
            setState(this.HEATING_BUFFER_TEMP, this.getHeatingBufferTemp(), true);
            setState(this.HEATING_BUFFER_MAX_TEMP, this.heating_buffer_max, true);
            setState(this.HEATING_BUFFER_TEMP_OVER, this.getHeatingBufferTempOvershoot(), true);
        }
        this.semp_client.writeState();
    }
}